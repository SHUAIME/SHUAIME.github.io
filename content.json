{"meta":{"title":"YANSHUAI'S BLOG","subtitle":null,"description":"好少年光芒万丈","author":"帅me","url":"https://www.shuaime.top"},"pages":[{"title":"about","date":"2018-12-12T14:14:36.000Z","updated":"2020-03-16T10:41:30.000Z","comments":false,"path":"about/index.html","permalink":"https://www.shuaime.top/about/index.html","excerpt":"","text":"[さくら荘のhojun] 与&nbsp; Mashiro&nbsp; （ 真（ま）白（しろ） ） 对话中... bot_ui_ini()","keywords":"关于"},{"title":"categories","date":"2020-03-25T10:02:29.000Z","updated":"2020-03-25T10:03:26.946Z","comments":false,"path":"categories/index.html","permalink":"https://www.shuaime.top/categories/index.html","excerpt":"","text":"","keywords":null},{"title":"bangumi","date":"2019-02-10T13:32:48.000Z","updated":"2020-03-16T10:41:30.000Z","comments":false,"path":"bangumi/index.html","permalink":"https://www.shuaime.top/bangumi/index.html","excerpt":"","text":"","keywords":null},{"title":"client","date":"2018-12-20T15:13:35.000Z","updated":"2020-03-16T10:41:30.000Z","comments":false,"path":"client/index.html","permalink":"https://www.shuaime.top/client/index.html","excerpt":"","text":"直接下载 or 扫码下载：","keywords":"Android客户端"},{"title":"comment","date":"2018-12-20T15:13:48.000Z","updated":"2020-03-16T10:41:30.000Z","comments":true,"path":"comment/index.html","permalink":"https://www.shuaime.top/comment/index.html","excerpt":"","text":"念两句诗 叙别梦、扬州一觉。 【宋代】吴文英《夜游宫·人去西楼雁杳》","keywords":"留言板"},{"title":"donate","date":"2018-12-20T15:13:05.000Z","updated":"2020-03-25T15:49:36.991Z","comments":false,"path":"donate/index.html","permalink":"https://www.shuaime.top/donate/index.html","excerpt":"","text":"","keywords":"谢谢饲主了喵~"},{"title":"lab","date":"2019-01-05T13:47:59.000Z","updated":"2020-03-16T10:41:30.000Z","comments":false,"path":"lab/index.html","permalink":"https://www.shuaime.top/lab/index.html","excerpt":"","text":"sakura主题balabala","keywords":"Lab实验室"},{"title":"links","date":"2018-12-19T15:11:06.000Z","updated":"2020-03-28T15:19:25.335Z","comments":true,"path":"links/index.html","permalink":"https://www.shuaime.top/links/index.html","excerpt":"","text":"","keywords":"友人帐"},{"title":"music","date":"2018-12-20T15:14:28.000Z","updated":"2020-03-28T14:58:51.576Z","comments":false,"path":"music/index.html","permalink":"https://www.shuaime.top/music/index.html","excerpt":"","text":"","keywords":"喜欢的音乐"},{"title":"tags","date":"2018-12-12T14:14:16.000Z","updated":"2020-03-25T10:04:03.232Z","comments":true,"path":"tags/index.html","permalink":"https://www.shuaime.top/tags/index.html","excerpt":"","text":""},{"title":"rss","date":"2018-12-20T15:09:03.000Z","updated":"2020-03-16T10:41:30.000Z","comments":true,"path":"rss/index.html","permalink":"https://www.shuaime.top/rss/index.html","excerpt":"","text":""},{"title":"theme-sakura","date":"2019-01-04T14:53:25.000Z","updated":"2020-03-16T10:41:30.000Z","comments":false,"path":"theme-sakura/index.html","permalink":"https://www.shuaime.top/theme-sakura/index.html","excerpt":"","text":"Hexo主题Sakura修改自WordPress主题Sakura，感谢原作者Mashiro","keywords":"Hexo 主题 Sakura 🌸"},{"title":"video","date":"2018-12-20T15:14:38.000Z","updated":"2020-03-16T10:41:30.000Z","comments":false,"path":"video/index.html","permalink":"https://www.shuaime.top/video/index.html","excerpt":"","text":"var videos = [ { img: 'https://lain.bgm.tv/pic/cover/l/0e/1e/218971_2y351.jpg', title: '朝花夕誓——于离别之朝束起约定之花', status: '已追完', progress: 100, jp: 'さよならの朝に約束の花をかざろう', time: '放送时间: 2018-02-24 SUN.', desc: ' 住在远离尘嚣的土地，一边将每天的事情编织成名为希比欧的布，一边静静生活的伊欧夫人民。在15岁左右外表就停止成长，拥有数百年寿命的他们，被称为“离别的一族”，并被视为活着的传说。没有双亲的伊欧夫少女玛奇亚，过着被伙伴包围的平稳日子，却总感觉“孤身一人”。他们的这种日常，一瞬间就崩溃消失。追求伊欧夫的长寿之血，梅萨蒂军乘坐着名为雷纳特的古代兽发动了进攻。在绝望与混乱之中，伊欧夫的第一美女蕾莉亚被梅萨蒂带走，而玛奇亚暗恋的少年克里姆也失踪了。玛奇亚虽然总算逃脱了，却失去了伙伴和归去之地……。' }, { img : 'https://lain.bgm.tv/pic/cover/l/0e/1e/218971_2y351.jpg', title: '朝花夕誓——于离别之朝束起约定之花', status: '已追完', progress: 100, jp: 'さよならの朝に約束の花をかざろう', time: '2018-02-24 SUN.', desc: ' 住在远离尘嚣的土地，一边将每天的事情编织成名为希比欧的布，一边静静生活的伊欧夫人民。在15岁左右外表就停止成长，拥有数百年寿命的他们，被称为“离别的一族”，并被视为活着的传说。没有双亲的伊欧夫少女玛奇亚，过着被伙伴包围的平稳日子，却总感觉“孤身一人”。他们的这种日常，一瞬间就崩溃消失。追求伊欧夫的长寿之血，梅萨蒂军乘坐着名为雷纳特的古代兽发动了进攻。在绝望与混乱之中，伊欧夫的第一美女蕾莉亚被梅萨蒂带走，而玛奇亚暗恋的少年克里姆也失踪了。玛奇亚虽然总算逃脱了，却失去了伙伴和归去之地……。' } ] .should-ellipsis{overflow:hidden;text-overflow:ellipsis;white-space:nowrap;width:95%;}.should-ellipsis-full{overflow:hidden;text-overflow:ellipsis;white-space:nowrap;width:100%;}.should-ellipsis i{position:absolute;right:24px;}.grey-text{color:#9e9e9e !important}.grey-text.text-darken-4{color:#212121 !important}html{line-height:1.15;-ms-text-size-adjust:100%;-webkit-text-size-adjust:100%}body{margin:0}img{border-style:none}progress{display:inline-block;vertical-align:baseline}::-webkit-file-upload-button{-webkit-appearance:button;font:inherit}html{-webkit-box-sizing:border-box;box-sizing:border-box}*,*:before,*:after{-webkit-box-sizing:inherit;box-sizing:inherit}ul:not(.browser-default){padding-left:0;list-style-type:none}ul:not(.browser-default)>li{list-style-type:none}.card{-webkit-box-shadow:0 2px 2px 0 rgba(0,0,0,0.14),0 3px 1px -2px rgba(0,0,0,0.12),0 1px 5px 0 rgba(0,0,0,0.2);box-shadow:0 2px 2px 0 rgba(0,0,0,0.14),0 3px 1px -2px rgba(0,0,0,0.12),0 1px 5px 0 rgba(0,0,0,0.2)}.hoverable{-webkit-transition:-webkit-box-shadow .25s;transition:-webkit-box-shadow .25s;transition:box-shadow .25s;transition:box-shadow .25s,-webkit-box-shadow .25s}.hoverable:hover{-webkit-box-shadow:0 8px 17px 0 rgba(0,0,0,0.2),0 6px 20px 0 rgba(0,0,0,0.19);box-shadow:0 8px 17px 0 rgba(0,0,0,0.2),0 6px 20px 0 rgba(0,0,0,0.19)}i{line-height:inherit}i.right{float:right;margin-left:15px}.bangumi .right{float:right !important}.material-icons{text-rendering:optimizeLegibility;-webkit-font-feature-settings:'liga';-moz-font-feature-settings:'liga';font-feature-settings:'liga'}.row{margin-left:auto;margin-right:auto;margin-bottom:20px}.row:after{content:\"\";display:table;clear:both}.row .col{float:left;-webkit-box-sizing:border-box;box-sizing:border-box;padding:0 .75rem;min-height:1px}.row .col.s12{width:100%;margin-left:auto;left:auto;right:auto}@media only screen and (min-width:601px){.row .col.m6{width:50%;margin-left:auto;left:auto;right:auto}}html{line-height:1.5;font-family:-apple-system,BlinkMacSystemFont,\"Segoe UI\",Roboto,Oxygen-Sans,Ubuntu,Cantarell,\"Helvetica Neue\",sans-serif;font-weight:normal;color:rgba(0,0,0,0.87)}@media only screen and (min-width:0){html{font-size:14px}}@media only screen and (min-width:992px){html{font-size:14.5px}}@media only screen and (min-width:1200px){html{font-size:15px}}.card{position:relative;margin:.5rem 0 1rem 0;background-color:#fff;-webkit-transition:-webkit-box-shadow .25s;transition:-webkit-box-shadow .25s;transition:box-shadow .25s;transition:box-shadow .25s,-webkit-box-shadow .25s;border-radius:2px}.card .card-title{font-size:24px;font-weight:300}.card .card-title.activator{cursor:pointer}.card .card-image{position:relative}.card .card-image img{display:block;border-radius:2px 2px 0 0;position:relative;left:0;right:0;top:0;bottom:0;width:100%}.card .card-content{padding:24px;border-radius:0 0 2px 2px}.card .card-content p{margin:0}.card .card-content .card-title{display:block;line-height:32px;margin-bottom:8px}.card .card-content .card-title i{line-height:32px}.card .card-reveal{padding:24px;position:absolute;background-color:#fff;width:100%;overflow-y:auto;left:0;top:100%;height:100%;z-index:3;display:none}.card .card-reveal .card-title{cursor:pointer;display:block}.waves-effect{position:relative;cursor:pointer;display:inline-block;overflow:hidden;-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none;-webkit-tap-highlight-color:transparent;vertical-align:middle;z-index:1;-webkit-transition:.3s ease-out;transition:.3s ease-out}.waves-effect img{position:relative;z-index:-1}.waves-block{display:block}::-webkit-input-placeholder{color:#d1d1d1}::-moz-placeholder{color:#d1d1d1}:-ms-input-placeholder{color:#d1d1d1}::-ms-input-placeholder{color:#d1d1d1}[type=\"radio\"]:not(:checked){position:absolute;opacity:0;pointer-events:none}[type=\"radio\"]:not(:checked)+span{position:relative;padding-left:35px;cursor:pointer;display:inline-block;height:25px;line-height:25px;font-size:1rem;-webkit-transition:.28s ease;transition:.28s ease;-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none}[type=\"radio\"]:not(:checked)+span:before,[type=\"radio\"]:not(:checked)+span:after{border-radius:50%}[type=\"radio\"]:not(:checked)+span:before,[type=\"radio\"]:not(:checked)+span:after{border:2px solid #5a5a5a}[type=\"radio\"]:not(:checked)+span:after{-webkit-transform:scale(0);transform:scale(0)}[type=\"checkbox\"]:not(:checked){position:absolute;opacity:0;pointer-events:none}[type=\"checkbox\"]:not(:checked):disabled+span:not(.lever):before{border:none;background-color:rgba(0,0,0,0.42)}[type=\"checkbox\"].filled-in:not(:checked)+span:not(.lever):before{width:0;height:0;border:3px solid transparent;left:6px;top:10px;-webkit-transform:rotateZ(37deg);transform:rotateZ(37deg);-webkit-transform-origin:100% 100%;transform-origin:100% 100%}[type=\"checkbox\"].filled-in:not(:checked)+span:not(.lever):after{height:20px;width:20px;background-color:transparent;border:2px solid #5a5a5a;top:0px;z-index:0}input[type=checkbox]:not(:disabled) ~ .lever:active:before,input[type=checkbox]:not(:disabled).tabbed:focus ~ .lever::before{-webkit-transform:scale(2.4);transform:scale(2.4);background-color:rgba(0,0,0,0.08)}input[type=range].focused:focus:not(.active)::-webkit-slider-thumb{-webkit-box-shadow:0 0 0 10px rgba(38,166,154,0.26);box-shadow:0 0 0 10px rgba(38,166,154,0.26)}input[type=range].focused:focus:not(.active)::-moz-range-thumb{box-shadow:0 0 0 10px rgba(38,166,154,0.26)}input[type=range].focused:focus:not(.active)::-ms-thumb{box-shadow:0 0 0 10px rgba(38,166,154,0.26)} 番组计划 这里将是永远的回忆 window.onload = function(){ videos.forEach(function(video, i){ $('#rootRow').append(` ${video.title} ${video.jp} ${video.status} ${video.title} ${video.jp} 放送时间: ${video.time} ${video.desc} ${video.status} `) }) }","keywords":"B站"}],"posts":[{"title":"JDK8新特性","slug":"JDK8新特性","date":"2019-12-28T02:00:10.000Z","updated":"2020-03-31T03:37:38.982Z","comments":true,"path":"posts/bcab918b/","link":"","permalink":"https://www.shuaime.top/posts/bcab918b/","excerpt":"Java JDK8 新特性 Lambda 函数式接口 streamAPI","text":"Java JDK8 新特性 Lambda 函数式接口 streamAPI 【Lambda表达式】Lambda表达式:带有参数变量的表达式，是一段可以传递的代码，可以被一次或多次执行,是一种精简的字面写法，其实就是把匿名内部类中“一定”要做的工作省略掉,然后由JVM通过推导把简化的表达式还原 格式：-&gt;可理解为“被用于”的意思 (参数) -&gt; 表达式或方法体 示例 (int a, int b) -&gt; { return a + b; } () -&gt; System.out.println(&quot;Hello World&quot;); (String s) -&gt; { System.out.println(s); } () -&gt; 42 () -&gt; { return 3.1415 }; Lambda 表达式的结构- Lambda 表达式可以具有零个，一个或多个参数。 - 可以显式声明参数的类型，也可以由编译器自动从上下文推断参数的类型。例如`(int a)` 与刚才相同 `(a)`。 - 参数用小括号括起来，用逗号分隔。例如 `(a, b)` 或 `(int a, int b)` 或 `(String a, int b, float c)`。 - 空括号用于表示一组空的参数。例如 `() -&gt; 42`。 - 当有且仅有一个参数时，如果不显式指明类型，则不必使用小括号。例如 `a -&gt; return a*a`。 - Lambda 表达式的正文可以包含零条，一条或多条语句。 - 如果 Lambda 表达式的正文只有一条语句，则大括号可不用写，且表达式的返回值类型要与匿名函数的返回类型相同。 - 如果 Lambda 表达式的正文有一条以上的语句必须包含在大括号（代码块）中，且表达式的返回值类型要与匿名函数的返回类型相同。 方法引用使用 Lambda 表达式，我们已经看到代码可以变得非常简洁。 例如，要创建一个比较器，以下语法就足够了 Comparator c = (Person p1, Person p2) -&gt; p1.getAge().compareTo(p2.getAge()); 然后，使用类型推断： Comparator c = (p1, p2) -&gt; p1.getAge().compareTo(p2.getAge()); 但是，我们可以使上面的代码更具表现力和可读性吗？我们来看一下： Comparator c = Comparator.comparing(Person::getAge); 使用 :: 运算符作为 Lambda 调用特定方法的缩写，并且拥有更好的可读性。 使用方式双冒号（::）操作符是 Java 中的方法引用。当们使用一个方法的引用时，目标引用放在::之前，目标引用提供的方法名称放在::之后，即 目标引用::方法。比如： Person::getAge; 在 Person 类中定义的方法 getAge 的方法引用。 然后我们可以使用 Function 对象进行操作： // 获取 getAge 方法的 Function 对象 Function&lt;Person, Integer&gt; getAge = Person::getAge; // 传参数调用 getAge 方法 Integer age = getAge.apply(p); 我们引用 getAge，然后将其应用于正确的参数。 目标引用的参数类型是 Function，T 表示传入类型，R 表示返回类型。比如，表达式person -&gt; person.getAge();，传入参数是person，返回值是 person.getAge()，那么方法引用 Person::getAge 就对应着 Function 类型 【函数式接口】函数式接口定义 带有@FunctionInterface注解的接口是函数式接口，编译器会对其做编译检查，不符合条件会报错 函数式接口允许默认方法存在 default-method 函数式接口允许静态方法存在 static-method 函数式接口允许对Object方法的重写例如 toString() equals() 线程接口Runnable就是一个典型的函数式接口 package java.lang; /** * The &lt;code&gt;Runnable&lt;/code&gt; interface should be implemented by any * class whose instances are intended to be executed by a thread. The * class must define a method of no arguments called &lt;code&gt;run&lt;/code&gt;. * &lt;p&gt; * This interface is designed to provide a common protocol for objects that * wish to execute code while they are active. For example, * &lt;code&gt;Runnable&lt;/code&gt; is implemented by class &lt;code&gt;Thread&lt;/code&gt;. * Being active simply means that a thread has been started and has not * yet been stopped. * &lt;p&gt; * In addition, &lt;code&gt;Runnable&lt;/code&gt; provides the means for a class to be * active while not subclassing &lt;code&gt;Thread&lt;/code&gt;. A class that implements * &lt;code&gt;Runnable&lt;/code&gt; can run without subclassing &lt;code&gt;Thread&lt;/code&gt; * by instantiating a &lt;code&gt;Thread&lt;/code&gt; instance and passing itself in * as the target. In most cases, the &lt;code&gt;Runnable&lt;/code&gt; interface should * be used if you are only planning to override the &lt;code&gt;run()&lt;/code&gt; * method and no other &lt;code&gt;Thread&lt;/code&gt; methods. * This is important because classes should not be subclassed * unless the programmer intends on modifying or enhancing the fundamental * behavior of the class. * * @author Arthur van Hoff * @see java.lang.Thread * @see java.util.concurrent.Callable * @since JDK1.0 */ @FunctionalInterface public interface Runnable { /** * When an object implementing interface &lt;code&gt;Runnable&lt;/code&gt; is used * to create a thread, starting the thread causes the object&#39;s * &lt;code&gt;run&lt;/code&gt; method to be called in that separately executing * thread. * &lt;p&gt; * The general contract of the method &lt;code&gt;run&lt;/code&gt; is that it may * take any action whatsoever. * * @see java.lang.Thread#run() */ public abstract void run(); } 我们也可以自己定义函数式接口,定义一个接口，使用lambda表达式传递接口并且调用 /** * 函数式接口 */ @FunctionalInterface //只是为了编译器检查 可以不写 public interface MyInterface { // 有且只有一个抽象方法 void sayHello(String name); //1.可以重写 Object的toString方法 @Override String toString(); // 也可以重写 Object的equals方法，还可以重写其他方法，这里只举个例子 @Override boolean equals(Object object); //2 可以有默认方法 default void sayHi(String name) { System.out.println(&quot;hi :&quot; + name); } //3 可以有静态方法 static boolean isEqual(Object obj) { return (null == obj) ? true : false; } } -------------------------------------- @Test public void test() { // 调用 需要一个String参数 然后打印输出 say(&quot;black猫&quot;, (name) -&gt; System.out.println(name + &quot;: hello&quot;)); } /** * 声明一个 接口传递方法 * @param name 接口需要的参数 * @param myInterface 是函数式类型接口 */ public void say(String name, MyInterface&lt;String&gt; myInterface) { myInterface.sayHello(name); } 其实我们不用自己定义这些函数式接口，java8给我们内置好了一些接口如下： 消费型接口 Consumer:void accept(T t); 供给型接口 Supplier:T get(); 函数型接口 Function&lt;T,R&gt;:R apply(T t); 断言型接口 Predicate:boolean test(T t); 消费型接口Consumer Consumer接口除了一个抽象方法accept(T t)还有一个默认实现的andThen(Consumer consumer),用来在前一个消费接口调用完accept()后使用,可以理解为一个连续性操作。 package java.util.function; import java.util.Objects; /** * Represents an operation that accepts a single input argument and returns no * result. Unlike most other functional interfaces, {@code Consumer} is expected * to operate via side-effects. * * &lt;p&gt;This is a &lt;a href=&quot;package-summary.html&quot;&gt;functional interface&lt;/a&gt; * whose functional method is {@link #accept(Object)}. * * @param &lt;T&gt; the type of the input to the operation * * @since 1.8 */ @FunctionalInterface public interface Consumer&lt;T&gt; { /** * Performs this operation on the given argument. * * @param t the input argument */ void accept(T t); /** * Returns a composed {@code Consumer} that performs, in sequence, this * operation followed by the {@code after} operation. If performing either * operation throws an exception, it is relayed to the caller of the * composed operation. If performing this operation throws an exception, * the {@code after} operation will not be performed. * * @param after the operation to perform after this operation * @return a composed {@code Consumer} that performs in sequence this * operation followed by the {@code after} operation * @throws NullPointerException if {@code after} is null */ default Consumer&lt;T&gt; andThen(Consumer&lt;? super T&gt; after) { Objects.requireNonNull(after); return (T t) -&gt; { accept(t); after.accept(t); }; } } 消费型接口Consumer的三个例子1.Consumer接口的accept消费一个参数(反转字符串) @Test public void test01(){ testConsumer01(&quot;hello&quot;,(msg)-&gt;System.out.println(new StringBuffer(msg).reverse().toString()); } //调用 accept public void testConsumer01(String str,Consumer&lt;String&gt; consumer){ consumer.accept(str); } 2.两个消费接口 调用accept，实现一个输出字符串大写，一个输出字符串输出小写 @Test public void test02(){ testConsumer02(&quot;Hello Lambda&quot;,(str)-&gt;{ System.out.println(str.toUpperCase()); },(str)-&gt;{ System.out.println(str.toLowerCase()); } ); } //两个消费接口 调用 accept public void testConsumer02(String str,Consumer&lt;String&gt; consumer1,Consumer&lt;String&gt; consumer2){ consumer1.accept(str); consumer2.accept(str); } 3.两个消费接口的accept和andThen组合操作字符 @Test public void test03() { String[] names = {&quot;张山,男&quot;, &quot;李诗,女&quot;, &quot;王武,男&quot;, &quot;马柳,女&quot;}; testConsumer03(names, (str) -&gt; { System.out.print(str.split(&quot;,&quot;)[0]+&quot;:&quot;); }, (str) -&gt; { System.out.println(str.split(&quot;,&quot;)[1]); } ); } public void testConsumer03(String[] names, Consumer&lt;String&gt; consumer1, Consumer&lt;String&gt; consumer2) { for (int i = 0; i &lt; names.length; i++) { //第一个消费接口处理完，第二个消费接口接着处理 consumer1.andThen(consumer2).accept(names[i]); } } 供给型接口Supplier 提供一个抽象方法get()，返回一个T package java.util.function; /** * Represents a supplier of results. * * &lt;p&gt;There is no requirement that a new or distinct result be returned each * time the supplier is invoked. * * &lt;p&gt;This is a &lt;a href=&quot;package-summary.html&quot;&gt;functional interface&lt;/a&gt; * whose functional method is {@link #get()}. * * @param &lt;T&gt; the type of results supplied by this supplier * * @since 1.8 */ @FunctionalInterface public interface Supplier&lt;T&gt; { /** * Gets a result. * * @return a result */ T get(); } 供给型接口Supplier的例子 利用供给型接口获取10个100内随机数，输出 @Test public void test04() { ArrayList&lt;Integer&gt; arr = testSupplier02(10, () -&gt; (int) (Math.random()*100)); for (int i = 0; i &lt; arr.size(); i++) { System.out.println(i + arr.get(i)); } } public ArrayList&lt;Integer&gt; testSupplier02(int size, Supplier&lt;Integer&gt; consumer) { ArrayList&lt;Integer&gt; arr = new ArrayList&lt;&gt;(); for (int i = 0; i &lt; size; i++) { int str = consumer.get(); arr.add(str); } return arr; } 函数型接口Function 提供一个抽象方法apply(T t)，返回一个R,Function&lt;T,V&gt; compose(Function function)在apply前执行，Function&lt;T,V&gt; andThen(Function function)在apply之后执行。 package java.util.function; import java.util.Objects; /** * Represents a function that accepts one argument and produces a result. * * &lt;p&gt;This is a &lt;a href=&quot;package-summary.html&quot;&gt;functional interface&lt;/a&gt; * whose functional method is {@link #apply(Object)}. * * @param &lt;T&gt; the type of the input to the function * @param &lt;R&gt; the type of the result of the function * * @since 1.8 */ @FunctionalInterface public interface Function&lt;T, R&gt; { /** * Applies this function to the given argument. * * @param t the function argument * @return the function result */ R apply(T t); /** * Returns a composed function that first applies the {@code before} * function to its input, and then applies this function to the result. * If evaluation of either function throws an exception, it is relayed to * the caller of the composed function. * * @param &lt;V&gt; the type of input to the {@code before} function, and to the * composed function * @param before the function to apply before this function is applied * @return a composed function that first applies the {@code before} * function and then applies this function * @throws NullPointerException if before is null * * @see #andThen(Function) */ default &lt;V&gt; Function&lt;V, R&gt; compose(Function&lt;? super V, ? extends T&gt; before) { Objects.requireNonNull(before); return (V v) -&gt; apply(before.apply(v)); } /** * Returns a composed function that first applies this function to * its input, and then applies the {@code after} function to the result. * If evaluation of either function throws an exception, it is relayed to * the caller of the composed function. * * @param &lt;V&gt; the type of output of the {@code after} function, and of the * composed function * @param after the function to apply after this function is applied * @return a composed function that first applies this function and then * applies the {@code after} function * @throws NullPointerException if after is null * * @see #compose(Function) */ default &lt;V&gt; Function&lt;T, V&gt; andThen(Function&lt;? super R, ? extends V&gt; after) { Objects.requireNonNull(after); return (T t) -&gt; after.apply(apply(t)); } /** * Returns a function that always returns its input argument. * * @param &lt;T&gt; the type of the input and output objects to the function * @return a function that always returns its input argument */ static &lt;T&gt; Function&lt;T, T&gt; identity() { return t -&gt; t; } } 函数型接口Function例子 把一个字符串，先转大写然后反转，最后转小写打印，采用三个函数型接口参数 @Test public void test3() { String msg = textFunction(&quot;hello-LAmbda&quot;, (str1) -&gt; { return str1.toUpperCase(); },(str1)-&gt;{ return str1.toLowerCase(); },(str1)-&gt;{ return new StringBuilder(str1).reverse().toString(); }); System.out.println(msg); } public String textFunction(String str, Function&lt;String, String&gt; function, Function&lt;String, String&gt; function2, Function&lt;String, String&gt; function3) { // function先执行然后是function2，但是function3在function2之前执行所以function2最后执行～～～ return function.andThen(function2.compose(function3)).apply(str); } 断言型接口 Predicate 一个抽象方法test(Test t),默认方法 and(Predicate predicate)/or(Predicate predicate)/negate(Predicate predicate)静态方法isEqual(Object targetRef) package java.util.function; import java.util.Objects; /** * Represents a predicate (boolean-valued function) of one argument. * * &lt;p&gt;This is a &lt;a href=&quot;package-summary.html&quot;&gt;functional interface&lt;/a&gt; * whose functional method is {@link #test(Object)}. * * @param &lt;T&gt; the type of the input to the predicate * * @since 1.8 */ @FunctionalInterface public interface Predicate&lt;T&gt; { /** * Evaluates this predicate on the given argument. * * @param t the input argument * @return {@code true} if the input argument matches the predicate, * otherwise {@code false} */ boolean test(T t); /** * Returns a composed predicate that represents a short-circuiting logical * AND of this predicate and another. When evaluating the composed * predicate, if this predicate is {@code false}, then the {@code other} * predicate is not evaluated. * * &lt;p&gt;Any exceptions thrown during evaluation of either predicate are relayed * to the caller; if evaluation of this predicate throws an exception, the * {@code other} predicate will not be evaluated. * * @param other a predicate that will be logically-ANDed with this * predicate * @return a composed predicate that represents the short-circuiting logical * AND of this predicate and the {@code other} predicate * @throws NullPointerException if other is null */ default Predicate&lt;T&gt; and(Predicate&lt;? super T&gt; other) { Objects.requireNonNull(other); return (t) -&gt; test(t) &amp;&amp; other.test(t); } /** * Returns a predicate that represents the logical negation of this * predicate. * * @return a predicate that represents the logical negation of this * predicate */ default Predicate&lt;T&gt; negate() { return (t) -&gt; !test(t); } /** * Returns a composed predicate that represents a short-circuiting logical * OR of this predicate and another. When evaluating the composed * predicate, if this predicate is {@code true}, then the {@code other} * predicate is not evaluated. * * &lt;p&gt;Any exceptions thrown during evaluation of either predicate are relayed * to the caller; if evaluation of this predicate throws an exception, the * {@code other} predicate will not be evaluated. * * @param other a predicate that will be logically-ORed with this * predicate * @return a composed predicate that represents the short-circuiting logical * OR of this predicate and the {@code other} predicate * @throws NullPointerException if other is null */ default Predicate&lt;T&gt; or(Predicate&lt;? super T&gt; other) { Objects.requireNonNull(other); return (t) -&gt; test(t) || other.test(t); } /** * Returns a predicate that tests if two arguments are equal according * to {@link Objects#equals(Object, Object)}. * * @param &lt;T&gt; the type of arguments to the predicate * @param targetRef the object reference with which to compare for equality, * which may be {@code null} * @return a predicate that tests if two arguments are equal according * to {@link Objects#equals(Object, Object)} */ static &lt;T&gt; Predicate&lt;T&gt; isEqual(Object targetRef) { return (null == targetRef) ? Objects::isNull : object -&gt; targetRef.equals(object); } } 断言型接口Predicate例子 判断一个字符串是否包含‘*’并且长度大于10 或者 字符串包含‘-’ public void test4() { String str = &quot;hello-lambda&quot;; boolean bool = textPredicate(str, (msg) -&gt; { return msg.indexOf(&#39;*&#39;) &gt; -1; }, (msg) -&gt; { return msg.length() &gt; 10; }, (msg) -&gt; { return msg.indexOf(&quot;-&quot;) &gt; -1; }); System.out.println(bool); } public boolean textPredicate(String str, Predicate&lt;String&gt; predicate, Predicate&lt;String&gt; predicate2, Predicate&lt;String&gt; predicate3) { return predicate.and(predicate2).or(predicate3).test(str); } 其他接口 根据上面的示例，每个接口结合源码可以写出自己想要的代码 函数式接口 参数类型 返回类型 用途 BiFunction&lt;T, U, R&gt; T, U R 对类型为 T, U 参数应用 操作，返回 R 类型的结 果。包含方法为 R apply(T t, U u); UnaryOperator (Function子接口) T T 对类型为T的对象进行一 元运算，并返回T类型的 结果。包含方法为 T apply(T t); BinaryOperator (BiFunction 子接口) T, T T 对类型为T的对象进行二 元运算，并返回T类型的 结果。包含方法为 T apply(T t1, T t2); BiConsumer&lt;T, U&gt; T, U void 对类型为T, U 参数应用 操作。包含方法为 void accept(T t, U u) ToIntFunction ToLongFunction ToDoubleFunction T int long double 分别计算int、long、 double、值的函数 IntFunction LongFunction DoubleFunction int long double R 参数分别为int、long、 double 类型的函数 【Stream API】Stream是Java8中处理集合的关键抽象概念，它可以指定你希望对集合进行的操作，可以执行非常复杂的查找、过滤和映射数据等操作。 使用Stream API 对集合数据进行操作，就类似于使用 SQL 执行的数 据库查询。 也可以使用Stream API来并行执行操作。 简而言之，Stream API 提供了一种高效且易于使用的处理数据的方式。 Stream流是数据渠道，用于操作数据源(集合、数组等)所生成的元素序列，以下三点注意。 Stream 自己不会存储元素。 Stream 不会改变源对象。相反，他们会返回一个持有结果的新Stream。 Stream 操作是延迟执行的。这意味着他们会等到需要结果的时候才执行。 Stream流操作的三大步 创建Stream流 中间操作 终止操作 创建Stream流集合创建Stream流/**** * java8中的Collection接口方法 * stream() 顺序流 * parallelStream() 并行流(后面再说这个) */ @Test public void test01() { //声明一个list List&lt;String&gt; list = new ArrayList&lt;String&gt;(); // default Stream&lt;E&gt; stream() 顺序流 // default Stream&lt;E&gt; parallelStream() 并行流 // 创建一个顺序流 Stream stream1 = list.stream(); // 创建一个并行流 Stream stream2 = list.parallelStream(); } 数组创建Stream流/**** * 数组创建Stream流 * Java8 中的 Arrays 的静态方法 stream() 可以获取数组流 */ @Test public void test02() { // Java8 中的 Arrays 的静态方法 stream() 可以获取数组流 // public static &lt;T&gt; Stream&lt;T&gt; stream(T[] array) String[] arr = new String[10]; Stream stream = Arrays.stream(arr); } 由值创建Stream流 Stream.of()/**** * 由值创建Stream流 * Stream.of() */ @Test public void test03() { // 可以使用静态方法 Stream.of(), 通过显式值创建一个流。它可以接收任意数量的参数。 Stream stream = Stream.of(&quot;1&quot;, &quot;2&quot;, &quot;3&quot;, &quot;4&quot;); } Stream.iterate() 和 Stream.generate()/**** * 由函数创建Stream无限流 * * seed种子 f 一元运算接口 * Stream.iterate(T seed,UnaryOperator f) * * supplier 供给型型接口 * Stream.generate(Supplier supplier) */ @Test public void test04() { // 可以使用静态方法 Stream.iterate() 和 Stream.generate(), 创建无限流。 // args1 seed 开始种子， args2 一元函数式接口 //迭代 public static&lt;T&gt; Stream&lt;T&gt; iterate(final T seed, final UnaryOperator&lt;T&gt; f) Stream stream1 = Stream.iterate(0, (x) -&gt; x + 1); //args 一个供给型接口 // 生成 public static&lt;T&gt; Stream&lt;T&gt; generate(Supplier&lt;T&gt; s) : Stream stream2 = Stream.generate(() -&gt; new Random().nextInt(100)); } 中间操作多个中间操作可以连接起来形成一个流水线，除非流水线上触发终止操作，否则中间操作不会执行任何的处理,而在终止操作时一次性全部处理，称为“惰性求值”。看一下一些常用的API： filter()/**** * filter(Predicate p) * 接收一个断言式接口，从流中排除不符合条件的元素 */ @Test public void test01() { Integer[] nums = {1, 2, 3, 4, 5, 6, 7, 8, 9, 0}; //使用Stream流的静态方法 of创建一个Stream流 Stream&lt;Integer&gt; stream = Stream.of(nums); //过滤操作 接收一个断言式接口 排除不符合条件的元素 输出结果 stream.filter((x) -&gt; x &gt; 5).forEach(System.out::println); } distinct()/*** * distinct() * 筛选，通过流所生成元素的 hashCode() 和 equals() 去除重复元素 */ @Test public void test02() { Integer[] nums = {1, 2, 3, 4, 5, 6, 7, 8, 9, 0, 0, 1}; //使用Stream流的静态方法 of创建一个Stream流 Stream&lt;Integer&gt; stream = Stream.of(nums); //去除重复的元素 stream.distinct().forEach(System.out::println); } limit()/*** * limit(long maxSize) * 接收一个long型数值流中的元素个数不操过maxSize个， */ @Test public void test03() { //使用Stream流的静态方法 generate创建一个Stream无限流 Stream stream = Stream.generate(() -&gt; new Random().nextInt(100)); //截断流获取前n个元素 最大n个 stream.limit(10).forEach(System.out::println); } skip()/*** * skip(long n) * 接收一个long型数值 跳过流前n个元素获取后面的元素和 limit(n)相反 */ @Test public void test04() { Integer[] nums = {1, 2, 3, 4, 5, 6, 7, 8, 9, 0, 0, 1}; //使用Stream流的静态方法 generate创建一个Stream无限流 Stream stream = Arrays.stream(nums); stream.skip(3).forEach(System.out::println); } map()/**** * map(Function f) * 接收一个函数作为参数，该函数会被应用到每个元素上，并将其映射成一个新的元素。 */ @Test public void test05() { Integer[] nums = {1, 2, 3, 4, 5, 6, 7, 8, 9, 0}; //使用Stream流的静态方法 generate创建一个Stream无限流 Stream&lt;Integer&gt; stream = Arrays.stream(nums); // 将每个元素*2 stream.map(x -&gt; x * 2).forEach(System.out::println); } flatMap()/**** * flatMap(ToDoubleFunction f) * 接收一个函数作为参数，将流中的每个值都换成另一个流，然后把所有流连接成一个流 */ @Test public void test08() { String[] strings = {&quot;hello lambda&quot;, &quot;hello&quot;, &quot;lambda&quot;}; // Stream的静态方法 of获取流 Stream&lt;String&gt; testStream = Stream.of(strings); // 流中的元素换成另一个流 分割处理 然后去重 打印 testStream.flatMap(str -&gt; Arrays.stream(str.split(&quot; &quot;))).distinct().forEach(System.out::println); } sorted()/** * sorted() * 产生一个新流，其中按自然顺序排序 */ @Test public void test09() { Integer[] nums = {1, 4, 2, 6, 3, 0, 9, 8, 7, 5}; Arrays.stream(nums).sorted().forEach(System.out::println); } /** * sorted(Comparator comparator) * 产生一个新流，其中按比较器顺序排序 */ @Test public void test10() { Integer[] nums = {-1, 4, -2, 6, -3, 0, 9, -8, 7, -5}; //例如 按照绝对值排序 Arrays.stream(nums).sorted(Comparator.comparing(x -&gt; Math.abs(x))).forEach(System.out::println); } 终止操作终端操作会从流的流水线生成结果。 其结果可以是任何不是流的值，例如:List、Integer、boolean allMatch()/**** * allMatch(Predicate predicate) * 接收一个断言式接口 全匹配 返回boolean */ @Test public void test01() { Integer[] nums = {1, 2, 3, 4, 5, 6, 7, 8, 9, 0}; //使用Stream流的静态方法 of创建一个Stream流 Stream&lt;Integer&gt; stream = Stream.of(nums); // 匹配数组元素是否全部大于等于0 System.out.println(stream.allMatch((x) -&gt; x &gt;= 0)); } anyMatch()/**** * anyMatch(Predicate predicate) * 接收一个断言式接口 至少匹配一个 返回boolean */ @Test public void test02() { Integer[] nums = {1, 2, 3, 4, 5, 6, 7, 8, 9, 0}; //使用Stream流的静态方法 of创建一个Stream流 Stream&lt;Integer&gt; stream = Stream.of(nums); // 匹配数组元素是否有大于10的元素 System.out.println(stream.anyMatch((x) -&gt; x &gt; 10)); } noneMatch()/**** * noneMatch(Predicate predicate) * 接收一个断言式接口 是否没有匹配的元素 返回boolean */ @Test public void test03() { Integer[] nums = {1, 2, 3, 4, 5, 6, 7, 8, 9, 0}; //使用Stream流的静态方法 of创建一个Stream流 Stream&lt;Integer&gt; stream = Stream.of(nums); // 匹配数组元素是否没有大于10的元素 System.out.println(stream.noneMatch((x) -&gt; x &gt; 10)); } findFirst()/**** * findFirst() * 返回Optional */ @Test public void test04() { Integer[] nums = {1, 2, 3, 4, 5, 6, 7, 8, 9, 0, 0, 1}; //使用数组Arrays创建流 Stream stream = Arrays.stream(nums); //返回流元素中的第一个元素 Optional optional = stream.findFirst(); System.out.println(optional.get()); } findAny()/**** * findAny() * 返回Optional */ @Test public void test05() { Integer[] nums = {2, 3, 4, 5, 6, 7, 8, 9, 0, 0, 1}; //使用数组Arrays创建流 Stream stream = Arrays.stream(nums); //返回流元素中的任意元素 Optional optional = stream.findAny(); System.out.println(optional.get()); } count()/**** * count() * 返回流元素总数 Long型 */ @Test public void test06() { Integer[] nums = {2, 3, 4, 5, 6, 7, 8, 9, 0, 0, 1}; //使用数组Arrays创建流 Stream stream = Arrays.stream(nums); Long aLong = stream.count(); System.out.println(aLong); } max()/**** * max(Comparator comparator) * 返回流元素最大值 * 接收一个比较器 */ @Test public void test07() { Integer[] nums = {2, 3, 4, 5, 6, 7, 8, 9, 0, 0, 1}; //使用数组Arrays创建流 Stream&lt;Integer&gt; stream = Arrays.stream(nums); //返回流元素中的最大元素 Optional optional = stream.max(Integer::compare); System.out.println(optional.get()); } min()/**** * max(Comparator comparator) * 返回流元素最小值 * 接收一个比较器 */ @Test public void test08() { Integer[] nums = {2, 3, 4, 5, 6, 7, 8, 9, 0, 0, 1}; //使用数组Arrays创建流 Stream&lt;Integer&gt; stream = Arrays.stream(nums); //返回流元素中的最小元素 Optional optional = stream.min(Integer::compare); System.out.println(optional.get()); } forEach()/**** * forEach(Consumer consumer) * 接收一个消费性接口 * 内部迭代(使用 Collection 接口需要用户去做迭代，称为外部迭代。 * 相反，Stream API 使用内部 迭代——它帮你把迭代做了) */ @Test public void test09() { Integer[] nums = {2, 3, 4, 5, 6, 7, 8, 9, 0, 0, 1}; Arrays.stream(nums).forEach(System.out::println); } reduce() /*** * reduce（BinaryOperator&lt;T&gt; accumulator） * 可以将流中元素反复结合起来，得到一个值。返回Optional * 接收一个二元运算接口 */ @Test public void test10() { Integer[] nums = {2, 3, 4, 5, 6, 7, 8, 9, 0, 0, 1}; // 依次累加 Object object = Arrays.stream(nums).reduce((x, y) -&gt; x + y).get(); System.out.println(object); } /*** * reduce（T iden, BinaryOperator&lt;T&gt; accumulator） * 接收一个二元运算接口 * 可以将流中元素反复结合起来，得到一个值。返回 T */ @Test public void test11() { Integer[] nums = {2, 3, 4, 5, 6, 7, 8, 9, 0, 0, 1}; // iden 作为一个值先加入运算然后 依次累加 Object object = Arrays.stream(nums).reduce(10, (x, y) -&gt; x * y); System.out.println(object); } stream.collect(Collectors.toList())/*** * collect（Collector collector） * 将流转换为其他形式。 * 接收一个 Collector接口的实现，用于给Stream中元素做汇总的方法 * Collectors 实用类提供了很多静态方法，可以方便地创建常见收集器实例 * Collectors.toList() * // 将数组变成了 list */ @Test public void test12() { Integer[] nums = {2, 3, 4, 5, 6, 7, 8, 9, 0, 0, 1}; Stream&lt;Integer&gt; stream = Arrays.stream(nums); List list = stream.collect(Collectors.toList()); // 将数组变成了 list System.out.println(list.size()); } stream.collect(Collectors.toSet())/*** * Collectors.toSet() * 将数组变成了 set */ @Test public void test13() { Integer[] nums = {2, 3, 4, 5, 6, 7, 8, 9, 0, 0, 1}; Stream&lt;Integer&gt; stream = Arrays.stream(nums); Set set = stream.collect(Collectors.toSet()); // 将数组变成了 set System.out.println(set.size()); } stream.collect(Collectors.toSet()) /*** * Collectors.toCollection(ArrayList::new) * Collectors.toCollection(HashSet::new) * 将数组变成了 Collection */ @Test public void test14() { Integer[] nums = {2, 3, 4, 5, 6, 7, 8, 9, 0, 0, 1}; Stream&lt;Integer&gt; stream = Arrays.stream(nums); Collection collection = stream.collect(Collectors.toCollection(HashSet::new)); // 将数组变成了 collection System.out.println(collection.size()); } stream.collect(Collectors.counting()) /*** * Collectors.counting() * 计算流中元素的个数 */ @Test public void test15() { Integer[] nums = {2, 3, 4, 5, 6, 7, 8, 9, 0, 0, 1}; Stream&lt;Integer&gt; stream = Arrays.stream(nums); Long integer = stream.collect(Collectors.counting()); System.out.println(integer); } stream.collect(Collectors.summingDouble()) /*** * Collectors.summingDouble(ToDoubleFunction mapper) * 计算流中元素的对象的某一个属性平均值 * 接收一个 计算int、long、 double、值的函数 接口 */ @Test public void test16() { List&lt;Employee&gt; employees = new ArrayList&lt;&gt;(3); Employee employe1 = new Employee(1, &quot;A1&quot;, 5000); Employee employe2 = new Employee(1, &quot;A2&quot;, 8000); Employee employe3 = new Employee(1, &quot;A3&quot;, 10000); employees.add(employe1); employees.add(employe2); employees.add(employe3); Stream&lt;Employee&gt; stream = employees.stream(); Double sumSalary = stream.collect(Collectors.summingDouble(Employee::getSalary)); System.out.println(sumSalary); } stream.collect(Collectors.averagingDouble()) /*** * Collectors.averagingDouble(ToDoubleFunction mapper) * 计算流中元素的对象的某一个属性平均值 * 接收一个 计算int、long、 double、值的函数 接口 */ @Test public void test17() { List&lt;Employee&gt; employees = new ArrayList&lt;&gt;(3); Employee employe1 = new Employee(1, &quot;A1&quot;, 5000); Employee employe2 = new Employee(1, &quot;A2&quot;, 8000); Employee employe3 = new Employee(1, &quot;A3&quot;, 10000); employees.add(employe1); employees.add(employe2); employees.add(employe3); Stream&lt;Employee&gt; stream = employees.stream(); Double avgSalary = stream.collect(Collectors.averagingDouble(Employee::getSalary)); System.out.println(avgSalary); } stream.collect(Collectors.joining()) /*** * Collectors.joining() * 连接流中元素的对象的某一个属性字符串 */ @Test public void test18() { List&lt;Employee&gt; employees = new ArrayList&lt;&gt;(3); Employee employe1 = new Employee(1, &quot;A1&quot;, 5000); Employee employe2 = new Employee(1, &quot;A2&quot;, 8000); Employee employe3 = new Employee(1, &quot;A3&quot;, 10000); employees.add(employe1); employees.add(employe2); employees.add(employe3); Stream&lt;Employee&gt; stream = employees.stream(); String names = stream.map((x) -&gt; x.getName() + &quot;-&quot;).collect(Collectors.joining()); System.out.println(names); } stream.collect(Collectors.minBy()) /*** * Collectors.maxBy(Comparator comparator) * 根据比较器选择最小值 * 接收一个比较器 */ @Test public void test19() { Integer[] nums = {1, 2, 3, 4, 5, 7, 8, 9, 3, 4, 56}; Stream&lt;Integer&gt; stream = Arrays.stream(nums); Optional optional = stream.collect(Collectors.minBy(Integer::compareTo)); System.out.println(optional.get()); } stream.collect(Collectors.reducing()) /*** * Collectors.reducing(U identity,Function&lt;? super T, ? extends U&gt; mapper,BinaryOperator&lt;U&gt; op) * 从一个作为累加器的初始值开始，利用BinaryOperator与流中元素逐个结合，从而归约成单个值 * 接收二元计算接口 */ @Test public void test20() { List&lt;Employee&gt; employees = new ArrayList&lt;&gt;(3); Employee employe1 = new Employee(1, &quot;A1&quot;, 5000); Employee employe2 = new Employee(1, &quot;A2&quot;, 8000); Employee employe3 = new Employee(1, &quot;A3&quot;, 10000); employees.add(employe1); employees.add(employe2); employees.add(employe3); Stream&lt;Employee&gt; stream = employees.stream(); // identity ： 0d 类型和后面的元素类型 保持一致 Double aDouble = stream.collect(Collectors.reducing(0d, Employee::getSalary, Double::sum)); System.out.println(aDouble); } stream.collect(Collectors.collectingAndThen()) /*** * Collectors.collectingAndThen(Collector&lt;T,A,R&gt; downstream,Function&lt;R,RR&gt; finisher) * 转换函数返回的类型 * 包裹另一个收集器，对其结果转换函数 */ @Test public void test21() { List&lt;Employee&gt; employees = new ArrayList&lt;&gt;(3); Employee employe1 = new Employee(1, &quot;A1&quot;, 5000); Employee employe2 = new Employee(1, &quot;A2&quot;, 8000); Employee employe3 = new Employee(1, &quot;A3&quot;, 10000); employees.add(employe1); employees.add(employe2); employees.add(employe3); Stream&lt;Employee&gt; stream = employees.stream(); // 转换函数返回的类型 返回set // 包裹另一个收集器，对其结果 set 进行处理 判断时候为空 Boolean bool = stream.collect(Collectors.collectingAndThen(Collectors.toSet(), Set::isEmpty)); System.out.println(bool); } stream.collect(Collectors.groupingBy())/*** * 根据某属性值对流分组，属 性为K，结果为V * Collectors.groupingBy(Function&lt;? super T, ? extends K&gt; classifier) * 传入一个 代表流元素的属性 * 返回 以属性为key value为 list的map */ @Test public void test22() { List&lt;Employee&gt; employees = new ArrayList&lt;&gt;(3); Employee employe1 = new Employee(1, &quot;A1&quot;, 5000); Employee employe2 = new Employee(1, &quot;A2&quot;, 8000); Employee employe3 = new Employee(1, &quot;A3&quot;, 10000); employees.add(employe1); employees.add(employe2); employees.add(employe3); Stream&lt;Employee&gt; stream = employees.stream(); Map map = stream.collect(Collectors.groupingBy(Employee::getName)); Set set=map.entrySet(); for (Object str:set) { System.out.println(str); System.out.println(map.get(str)); } } stream.collect(Collectors.partitioningBy())/*** * 根据true或false进行分区 * Collectors.groupingBy(Function&lt;? super T, ? extends K&gt; classifier) * 传入一个 代表流元素的属性 * 返回 以属性(flase/true)为key value为 list的map */ @Test public void test23() { List&lt;Employee&gt; employees = new ArrayList&lt;&gt;(3); Employee employe1 = new Employee(1, &quot;A1&quot;, 5000,false); Employee employe2 = new Employee(1, &quot;A2&quot;, 8000,true); Employee employe3 = new Employee(1, &quot;A3&quot;, 10000,false); employees.add(employe1); employees.add(employe2); employees.add(employe3); Stream&lt;Employee&gt; stream = employees.stream(); Map map = stream.collect(Collectors.partitioningBy(Employee::getFlag)); Set set=map.entrySet(); for (Object str:set) { System.out.println(str); System.out.println(map.get(str)); } }","categories":[{"name":"Java","slug":"Java","permalink":"https://www.shuaime.top/categories/Java/"}],"tags":[{"name":"JDK8","slug":"JDK8","permalink":"https://www.shuaime.top/tags/JDK8/"},{"name":"Lambda","slug":"Lambda","permalink":"https://www.shuaime.top/tags/Lambda/"},{"name":"函数式接口","slug":"函数式接口","permalink":"https://www.shuaime.top/tags/函数式接口/"}],"keywords":[{"name":"Java","slug":"Java","permalink":"https://www.shuaime.top/categories/Java/"}]},{"title":"Java总结篇...","slug":"Interview","date":"2019-12-01T07:47:28.000Z","updated":"2020-03-31T03:38:47.488Z","comments":true,"path":"posts/4decbe97/","link":"","permalink":"https://www.shuaime.top/posts/4decbe97/","excerpt":"emmm……瞎几把画的一些总结","text":"emmm……瞎几把画的一些总结 【基础】 int float short double long char 占字节数？ int 占 4 字节 short 占 2 字节 long 占 8 字节 float 占 4 字节 double 占 8 字节 char 占 2 字节 int 范围？float 范围？ int 范围 -2^31~2^31-1 float 范围 -3.4E+38~3.4E+38 hashcode 和 equals 的关系 两个对象equals方法相等时hashCode方法一定相等,但hashCode方法相等时equals方法不一定相等 因为如果没有重写hashCode方法,无法保证两个对象equals时hashCode比逊相等的条件 深拷贝、浅拷贝区别 浅拷贝: 值类型字段进行复制 引用类型字段复制引用不复制引用的对象 深拷贝: 不管值类型还是引用类型都复制独一份 java 异常体系？RuntimeException Exception Error 的区别，举常见的例子 异常的超类为Throwable 之下有error和Exception两个子类 erro: 错误程序不能运行本身没办法解决 Exception: 程序可以运行可以捕捉到的异常本身可以解决 RuntimeException: 运行时异常程序在运行时发生的异常可以捕获也可以不捕获 【集合】集合这块关注一下 1.8 的实现吧，和 1.7 相比变化了很多 Collection 有什么子接口、有哪些具体的实现 Collection主要包括两个子接口Set和List List: ArrayList LinkedList Vector Set: HashSet TreeSet 讲一下 hashMap 原理。hashMap 可以并发读么？并发写会有什么问题？ jdk7在实例化以后，底层创建了长度是16的一维数组Entry[] table。 ...可能已经执行过多次put... map. put(key1, value1): 首先，调用key1所在类的hashCode() 计算key1哈希值,此哈希值经过某种算法计算以后，得到在Entry数组 中的存放位置。 如果此位置上的数据为空，此时的key1-value1添加成功。---- 情况1 如果此位置上的数据不为空，(意味着此位置上存在一个或多个数据(以链表形式存在)),比较key1和已经存在的一个或多数据的哈希值: 如果key1的哈希值与已经存在的数据的哈希值都不相同，此时key1-value1 添加成功。----情况2 如果key1的哈希值和已经存在的某一个数据(key2-value2)的哈希值相同，继续比较:调用key1 所在类的equals(key2) 如果equals()返回false:此时key1-value1添加成功。---- 情况3 如果equaLs()返回true:使用value1替换value2。 补充:关于情况2和情况3:此时key1 -value1和原来的数据以链表的方式存储。 jdk8相较于jdk7在底层实现方面的不同: 1. new HashMap(): 底层没有创建-一个长度为16的数组 2. jdk 8底层的数组是: Node[], 而非Entry[] 3.首次调用put()方法时，底层创建长度为16的数组 4. jdk7底层结构只有:数组+链表。jdk8 中底层结构:数组+链表+红黑树。 当数组的某一个索引位置上的元素以链表形式存在的数据个数&gt; 8且当前数组的长度&gt; 64时,此时此索引位置上的所有 数据改为使用红黑树存储。 集合在迭代的过程中，插入或删除数据会怎样？ 会抛出java.util.ConcurrentModificationException的异常 【并发】【线程】 进程和线程的区别？并行和并发的区别？了解协程么？ 进程: 通俗理解一个运行起来的程序或者软件叫做进程 线程：进程中独立、可调配的执行单位，最小的执行单位 普通解释： 并发：交替做不同事情的能力 并行：同时做不同事情的能力 专业术语： 并发：不同的代码块交替执行 并行：不同的代码块同时执行 线程的生命周期有哪些状态？怎么转换？ New（初始化状态） Runnable（可运行 / 运行状态） Blocked（阻塞状态） Waiting（无限时等待） Timed_Waiting（有限时等待） Terminated（终止状态） wait 和 sleep 有什么区别？什么情况下会用到 sleep？ sleep是thread类的静态方法 wait是Object的动态方法 sleep让出CPU资源,不释放锁 wait让出CPU资源,也释放锁 wait需要结合同步锁使用,sleep不需要 sleep必须传入时间参数,wait可以传也可以不传 怎么停止线程？ interrupt()方法 volatile关键字 public class Demo1 { private static volatile boolean stop = false; public static void main(String[] args) throws InterruptedException{ Thread thread = new Thread(()-&gt;{ inti=0; while(!stop) { i++; } }) ; thread.start(); System.out.println(&quot;线程开始”) ; Thread.sleep( millis: 1000) ; stop = true } } 怎么控制多个线程按序执行？ 使用join()方法 利用Executors线程池 volatile 关键字有什么用？怎么理解可见性，一般什么场景去用可见性 Volatile关键字的主要作用是使变量在多个线程之间可见,使得多线程之间可以进行变量的变更 讲一下 threadLocal 原理，threadLocal 是存在 jvm 内存哪一块的 每个线程内部都有一个Map，我们每当定义一个ThreadLocal变量，就相当于往这个Map里放了一个key，并定义一个对应的value。每当使用ThreadLocal，就相当于get(key)，寻找其对应的value 【线程池】 常用的线程池有哪些？用的哪个线程池？什么情况下怎么选择？ newFixedThreadPool:创建固定大小的线程池 newCaChedTheadPool:创建可缓存的线程池 newScheduleThreadPool:创建大小无限的线程池 newSingleTreadExecutor:创建单线程的线程池 什么是线程池？ 为什么要使用它？ 创建线程需要花费昂贵的时间,如果任务来了才创建线程那么响应时间会变长,而且一个进程创建的线程数是有限的,为了避免这些问题,在启动程序的时候就创建若干线程来处理响应,他们被称为线程池 【JVM】【内存与 GC】 jvm 内存区域分布？gc 发生在哪些部分？ 程序计数器 栈 本地方法栈 堆 方法区 gc 发生在堆中 垃圾回收算法的了解。现在用的什么回收算法？ 标记-清除算法 复制算法 标记整理算法 分代收集算法 【异常与调优】 oom OOM，全称“Out Of Memory”，翻译成中文就是“内存用完了”，来源于java.lang.OutOfMemoryError。 当JVM因为没有足够的内存来为对象分配空间并且垃圾回收器也已经没有空间可回收时，就会抛出这个error 最常见的OOM情况有以下三种： java.lang.OutOfMemoryError: Java heap space ------&gt;java堆内存溢出，此种情况最常见，一般由于内存泄露或者堆的大小设置不当引起。对于内存泄露，需要通过内存监控软件查找程序中的泄露代码，而堆大小可以通过虚拟机参数-Xms,-Xmx等修改。 java.lang.OutOfMemoryError: PermGen space ------&gt;java永久代溢出，即方法区溢出了，一般出现于大量Class或者jsp页面，或者采用cglib等反射机制的情况，因为上述情况会产生大量的Class信息存储于方法区。此种情况可以通过更改方法区的大小来解决，使用类似-XX:PermSize=64m -XX:MaxPermSize=256m的形式修改。另外，过多的常量尤其是字符串也会导致方法区溢出。 java.lang.StackOverflowError ------&gt; 不会抛OOM error，但也是比较常见的Java内存溢出。JAVA虚拟机栈溢出，一般是由于程序中存在死循环或者深度递归调用造成的，栈大小设置太小也会出现此种溢出。可以通过虚拟机参数-Xss来设置栈的大小。 【类加载器】 类加载过程？ 1.加载是将class文件加载到虚拟机中,在jvm的方法区中生成该类的类信息.在jvm的堆中生成java.lang.class对象. 2.连接分为: 验证,准备,解析. 验证-&gt; class文件格式,元数据验证,字节码验证,符号引用验证. 准备-&gt; 为类变量分配内存并设置类变量初始值(赋0)的阶段. 解析-&gt; 符号引用转为直接引用 3.初始化 执行类构造器 【Spring】 spring 介绍一下 Spring是一个轻量级的控制反转(IOC)和面向切面(AOP)的容器框架 讲一下 IOC、AOP IOC(控制反转):Inverse of Control 将对象的创建权反转到Spring容器主要目的是用来解耦 AOP(面向切面): AOP是一种编程思想,是基于OOP基础之上更高级的一种编程思想,可以说是OOP的一种补充和完善 AOP利用一种横切技术,将一些公共行为封装到一个可以重用的模块,并将其成为切面(Aspect) AOP相关概念: 连接点joinpoint 切入点pointcut 通知advice 目标对象target 代理对象proxy 织入weaving 切面aspect IOC怎么防止循环依赖 SpringIOC解决循环依赖的思路就是依靠缓存,当我们创建实例与属性注入实例这俩个步骤之间的时候，我们引入缓存，将这些已经创建好但是并没有注入属性的实例放到缓存里，而这些放在缓存里但是没有被注入属性的实例对象，就是解决循环依赖的方法，打个比方：A对象的创建需要引用到B对象，而B对象的创建也需要A对象，而此时当B对象创建的时候直接从缓存里引用A对象（虽然不是完全体A对象，毕竟没有赋值处理），当B对象完成创建以后再被A对象引用进去，则A对象也完成了创建。 AOP的实现原理、动态代理过程\\ JDK动态代理 Cglib动态代理 Spring MVC处理请求的过程？ 浏览器发送请求 前端控制器(DIspatcherServlet)拦截客户请求，根据指定的处理器映射器找到对应的处理器 根据不同的处理器，使用不同的处理器适配器转化后，执行处理器 处理器处理完请求后返回ModelAndView 前端控制器根据ModelAndView找到视图解析器对返回结果进行解析，解析完成后找到对应的view做出响应 【 MySQL】 数据仓库与 mysql 区别？hive 和 mysql 有什么区别？spark 和 hadoop 区别？mapreduce 互相等待，怎么解决？ acid 含义？事务隔离级别？幻读怎么解决的？ 用过 mysql 的锁么？有哪些锁？ MyISAM、InnoDB 区别？为什么不用 MyISAM？ mvcc 原理？多版本数据存放在哪？ mysql 脏页？ redo log，undo log？ 索引 innodb 的索引结构是什么？什么是聚簇索引？ b+ 树与 b 树的区别？ b+ 树与二叉树区别，优点？为什么不用红黑树？ 多列索引的结构 字符串类型和数字类型索引的效率？数据类型隐式转换 主键与普通索引的联系？存储上的区别？ sql join 和 in 怎么选择？有什么区别？ union 和 union all 有什么区别？怎么选择？ 怎么处理 sql 慢查询？ 索引用得不太正常怎么处理？同时有（a，b）和（a，c）的索引，查询 a 的时候，会选哪个索引？ 跨库分页的实现？ 分库分表有哪些策略？怎么保证 id 唯一？ 对 uuid 的理解？知道哪些 GUID、Random 算法？ 主键选随机 id、uuid 还是自增 id？为什么？主键有序无序对数据库的影响？ 主从复制的过程？复制原理？怎么保证强一致性？ 【设计模式】 工厂方法和抽象工厂的区别 装饰器和代理区别 单例 对于单例，你知道哪些实现方法？ 实现一个懒加载单例 双重校验锁为什么需要双重校验？","categories":[{"name":"Java","slug":"Java","permalink":"https://www.shuaime.top/categories/Java/"}],"tags":[{"name":"Java","slug":"Java","permalink":"https://www.shuaime.top/tags/Java/"}],"keywords":[{"name":"Java","slug":"Java","permalink":"https://www.shuaime.top/categories/Java/"}]},{"title":"Spring Boot项目接入QQ登录教程","slug":"Spring-Boot项目接入QQ登录教程","date":"2019-11-17T14:05:21.000Z","updated":"2020-03-30T12:27:49.912Z","comments":true,"path":"posts/f0580ace/","link":"","permalink":"https://www.shuaime.top/posts/f0580ace/","excerpt":"写作时间：2019-11-17 实现目标：Spring Boot接入QQ登录涉及知识：QQOAuth2.0接入","text":"写作时间：2019-11-17 实现目标：Spring Boot接入QQ登录涉及知识：QQOAuth2.0接入 【创建项目】使用IDEA创建一个Spring Boot项目，依赖下面会给出 pom.xml&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt; &lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;parent&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt; &lt;version&gt;2.2.2.RELEASE&lt;/version&gt; &lt;relativePath/&gt; &lt;!-- lookup parent from repository --&gt; &lt;/parent&gt; &lt;groupId&gt;com.yan&lt;/groupId&gt; &lt;artifactId&gt;qqconnection&lt;/artifactId&gt; &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt; &lt;properties&gt; &lt;java.version&gt;1.8&lt;/java.version&gt; &lt;/properties&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-thymeleaf&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.projectlombok&lt;/groupId&gt; &lt;artifactId&gt;lombok&lt;/artifactId&gt; &lt;optional&gt;true&lt;/optional&gt; &lt;/dependency&gt; &lt;!-- okhttp依赖--&gt; &lt;dependency&gt; &lt;groupId&gt;com.squareup.okhttp3&lt;/groupId&gt; &lt;artifactId&gt;okhttp&lt;/artifactId&gt; &lt;version&gt;3.14.1&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;com.alibaba&lt;/groupId&gt; &lt;artifactId&gt;fastjson&lt;/artifactId&gt; &lt;version&gt;1.2.58&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;exclusions&gt; &lt;exclusion&gt; &lt;groupId&gt;org.junit.vintage&lt;/groupId&gt; &lt;artifactId&gt;junit-vintage-engine&lt;/artifactId&gt; &lt;/exclusion&gt; &lt;/exclusions&gt; &lt;/dependency&gt; &lt;/dependencies&gt; &lt;build&gt; &lt;plugins&gt; &lt;plugin&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt; &lt;/plugin&gt; &lt;/plugins&gt; &lt;/build&gt; &lt;/project&gt; application.properties 配置信息#QQ互联申请的应用id QQAPPID=101813698 #QQ互联申请的应用key QQAPPKEY=7265da646c6cf33f6326f6844c1c4ef3 #应用回调地址 &#39;:&#39; 和 &#39;/&#39;等特殊字符需要转义 原本的url是 http://127.0.0.1:8080/login redirect_uri=http%3A%2F%2F127.0.0.1%3A8080%2Flogin 【Controller】package com.yan.controller; import com.alibaba.fastjson.JSONObject; import com.yan.entity.User; import com.yan.util.QQConnection; import org.springframework.beans.factory.annotation.Autowired; import org.springframework.stereotype.Controller; import org.springframework.ui.Model; import org.springframework.web.bind.annotation.RequestMapping; import org.springframework.web.bind.annotation.RequestParam; @Controller public class IndexController { @Autowired private QQConnection qqConnection; @RequestMapping(&quot;/&quot;) public String index(){ // 第一步 获取QQ登录按钮url 自己拼接，这是只是演示步骤，无实际意义 qqConnection.getUrl(); return &quot;index.html&quot;; } @RequestMapping(&quot;/login&quot;) public Object qqLogin(@RequestParam(&quot;code&quot;)String code , @RequestParam(&quot;state&quot;) String state , Model model){ User user = new User(); System.out.println(&quot;第二步：获取QQ互联返回的code=&quot;+code); // 第三步 获取access token String accessToken = qqConnection.getAccessToken(code); // 第四步 获取登陆后返回的 openid、appid 以JSON对象形式返回 JSONObject userInfo = qqConnection.getUserOpenID(accessToken); // 第五步获取用户有效(昵称、头像等）信息 以JSON对象形式返回 String oauth_consumer_key = userInfo.getString(&quot;client_id&quot;); String openid = userInfo.getString(&quot;openid&quot;); JSONObject userRealInfo = qqConnection.getUserInfo(accessToken,oauth_consumer_key,openid); user.setOpenid(openid); user.setNickName(userRealInfo.getString(&quot;nickname&quot;)); user.setAvatar(userRealInfo.getString(&quot;figureurl_qq&quot;)); model.addAttribute(&quot;User&quot;,user); return &quot;index.html&quot;; } } 【工具类】编写工具类QQConnection 配合controller 完成整个登录认证流程，具体我觉得博客上没必要再写了。请配合QQ互联给的文档 package com.yan.util; import com.alibaba.fastjson.JSONObject; import okhttp3.OkHttpClient; import okhttp3.Request; import okhttp3.Response; import org.springframework.beans.factory.annotation.Value; import org.springframework.stereotype.Component; import java.io.IOException; @Component public class QQConnection { // 读取appid @Value(&quot;${QQAPPID}&quot;) private String QQAppID; @Value(&quot;${QQAPPKEY}&quot;) // 读取appkey private String QQAppKEY; //读取redirect_uri @Value(&quot;${redirect_uri}&quot;) private String redirect_uri; // 第一步：获取 QQ登录按钮url 几乎等于手动拼接 无太大意义 public String getUrl(){ String url = &quot;https://graph.qq.com/oauth2.0/authorize?display=pc&amp;response_type=code&amp;client_id=&quot; + QQAppID+&quot;&amp;redirect_uri=&quot;+redirect_uri+&quot;&amp;state=200&quot;; System.out.println(&quot;第一步：获取QQ登录按钮的url=&quot;+url); return null; } /* 第三步：根据前一步得到的 Authorization Code 获取access token */ public String getAccessToken(String code){ String accessTaken=&quot;&quot;; String url = &quot;https://graph.qq.com/oauth2.0/token?display=pc&amp;grant_type=authorization_code&amp;client_id=&quot;+QQAppID+&quot;&amp;client_secret=&quot;+QQAppKEY+&quot;&amp;redirect_uri=&quot;+redirect_uri+&quot;&amp;code=&quot;+code; OkHttpClient client = new OkHttpClient(); Request request = new Request.Builder() .url(url) .build(); try (Response response = client.newCall(request).execute()) { assert response.body() != null; String responseString = response.body().string(); accessTaken = responseString.split(&quot;=&quot;)[1].split(&quot;&amp;&quot;)[0]; System.out.println(&quot;第三步：获取QQ互联返回的accessTaken=&quot;+accessTaken); } catch (IOException e) { e.printStackTrace(); } return accessTaken; } /* 第四步：根据得到的access token 获取用户的 openID 和 oauth_consumer_key：申请QQ登录成功后，分配给应用的openid(对当前网站应用唯一，可用于检测是否为同一用户的凭证） */ public JSONObject getUserOpenID(String accessToken){ JSONObject userInfo = new JSONObject(); String urlProvideByQQConnection = &quot;https://graph.qq.com/oauth2.0/me&quot;; String requestUrl =urlProvideByQQConnection+&quot;?access_token=&quot;+accessToken; OkHttpClient client = new OkHttpClient(); Request request = new Request.Builder() .url(requestUrl) .build(); try (Response response = client.newCall(request).execute()) { assert response.body() != null; String UserInfoString = response.body().string().split(&quot; &quot;)[1]; userInfo = JSONObject.parseObject(UserInfoString); System.out.println(&quot;第四步：获取QQ互联返回的openid和分配给应用的appid：&quot;+userInfo); } catch (IOException e) { e.printStackTrace(); } return userInfo; } /* 第五步：根据 access_token、oauth_consumer_key(上一步返回的client_id）、openid 获取用户有效信息 (昵称、头像等） 返回json对象 */ public JSONObject getUserInfo(String access_token , String oauth_consumer_key , String openid ){ JSONObject userRealInfo = new JSONObject(); String urlProvideByQQConnection= &quot;https://graph.qq.com/user/get_user_info?&quot;; String requestUrl = urlProvideByQQConnection+&quot;access_token=&quot;+access_token+&quot;&amp;oauth_consumer_key=&quot;+oauth_consumer_key+&quot;&amp;openid=&quot;+openid; OkHttpClient client = new OkHttpClient(); Request request = new Request.Builder() .url(requestUrl) .build(); try (Response response = client.newCall(request).execute()) { assert response.body() != null; String UserRealInfoString = response.body().string(); userRealInfo = JSONObject.parseObject(UserRealInfoString); System.out.println(&quot;第五步：获取QQ互联返回的用户有效信息：&quot;+userRealInfo); } catch (IOException e) { e.printStackTrace(); } return userRealInfo; } } 【User类】package com.yan.entity; import lombok.Data; @Data public class User { private String nickName; private String avatar; private String openid; } 【前端】&lt;!DOCTYPE html&gt; &lt;html xmlns:th=&quot;http://www.thymeleaf.org&quot; &gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;Spring Boot接入QQ登录&lt;/title&gt; &lt;link href=&quot;https://cdn.jsdelivr.net/npm/bootstrap@3.3.7/dist/css/bootstrap.min.css&quot; rel=&quot;stylesheet&quot;&gt; &lt;link rel=&quot;stylesheet&quot; type=&quot;text/css&quot; href=&quot;/layui/css/layui.css&quot;&gt; &lt;style&gt; #box-success{ margin-top: 200px; box-shadow: 0px 5px 40px -1px rgba(96, 118, 243, 0.31); text-align: center; height: 400px; } #box-fail{ margin-top: 200px; box-shadow: 0px 5px 40px -1px rgba(209, 134, 148, 0.31); text-align: center; height: 400px; } #qqicon{ margin-top: 0px; width: 200px; height: 200px; } #login{ width: 40%; text-decoration: none; margin-top: 50px; } &lt;/style&gt; &lt;script src=&quot;https://cdn.bootcss.com/jquery/3.4.1/jquery.js&quot;&gt;&lt;/script&gt; &lt;script src=&quot;/layer/layer.js&quot;&gt;&lt;/script&gt; &lt;script src=&quot;/layui/layui.js&quot;&gt;&lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;div class=&quot;row&quot;&gt; &lt;div class=&quot;row&quot;&gt; &lt;div class=&quot;col-md-3&quot;&gt; &lt;/div&gt; &lt;div class=&quot;col-md-6&quot; id=&quot;container&quot;&gt; &lt;div id=&quot;box-fail&quot; th:if=&quot;${User == null}&quot;&gt; &lt;div class=&quot;alert alert-danger&quot; role=&quot;alert&quot;&gt;当前未登录&lt;/div&gt; &lt;img id=&quot;qqicon&quot; src=&quot;/img/user.png&quot;&gt; &lt;br&gt; &lt;a id=&quot;login&quot; class=&quot;layui-btn layui-btn-normal&quot; href=&quot;https://graph.qq.com/oauth2.0/show?which=Login&amp;display=pc&amp;display=pc&amp;response_type=code&amp;client_id=101813698&amp;redirect_uri=http%3A%2F%2F127.0.0.1%3A8080%2Flogin&amp;state=200&quot;&gt; QQ登录 &lt;/a&gt; &lt;/div&gt; &lt;div id=&quot;box-success&quot; th:if=&quot;${User != null}&quot;&gt; &lt;div class=&quot;alert alert-success&quot; role=&quot;alert&quot; th:text=&quot;&#39;登陆成功，欢迎：&#39;+${User.nickName}+&#39;！&#39;&quot;&gt;&lt;/div&gt; &lt;img id=&quot;qqicon&quot; class=&quot;img-circle&quot; th:src=&quot;${User.avatar}&quot;&gt; &lt;br&gt; &lt;/div&gt; &lt;/div&gt; &lt;div class=&quot;col-md-3&quot;&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;/body&gt; &lt;/html&gt; 【演示效果】未登录 跳转登录 登录之后返回登录之后显示头像和昵称 【项目地址】Github地址： https://github.com/SHUAIME/QQConnection","categories":[{"name":"Java","slug":"Java","permalink":"https://www.shuaime.top/categories/Java/"}],"tags":[{"name":"Java","slug":"Java","permalink":"https://www.shuaime.top/tags/Java/"}],"keywords":[{"name":"Java","slug":"Java","permalink":"https://www.shuaime.top/categories/Java/"}]},{"title":"Spring Cloud Netflix","slug":"SpringCloudNetflix","date":"2019-11-15T06:00:15.000Z","updated":"2020-03-30T12:29:59.957Z","comments":true,"path":"posts/33f411d/","link":"","permalink":"https://www.shuaime.top/posts/33f411d/","excerpt":"写作时间：2019-11-15实现目标：Spring Cloud Netflix涉及知识：微服务架构解决方案","text":"写作时间：2019-11-15实现目标：Spring Cloud Netflix涉及知识：微服务架构解决方案 【概述】Spring Cloud 是一个相对比较新的微服务框架，2016 才推出 1.0 的 Release 版本. 但是其更新特别快，几乎每 1-2 个月就有一次更新，虽然 Spring Cloud 时间最短, 但是相比 Dubbo 等 RPC 框架, Spring Cloud 提供的全套的分布式系统解决方案。 Spring Cloud 为开发者提供了在分布式系统（配置管理，服务发现，熔断，路由，微代理，控制总线，一次性 Token，全居琐，Leader 选举，分布式 Session，集群状态）中快速构建的工具，使用 Spring Cloud 的开发者可以快速的启动服务或构建应用、同时能够快速和云平台资源进行对接。 【创建统一的依赖管理】创建一个工程名为 hello-spring-cloud-dependencies 的项目，pom.xml 配置文件如下： &lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt; &lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;parent&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt; &lt;version&gt;2.0.2.RELEASE&lt;/version&gt; &lt;/parent&gt; &lt;groupId&gt;com.yan&lt;/groupId&gt; &lt;artifactId&gt;hello-spring-cloud-dependencies&lt;/artifactId&gt; &lt;version&gt;1.0.0-SNAPSHOT&lt;/version&gt; &lt;packaging&gt;pom&lt;/packaging&gt; &lt;properties&gt; &lt;!-- Environment Settings --&gt; &lt;java.version&gt;1.8&lt;/java.version&gt; &lt;project.build.sourceEncoding&gt;UTF-8&lt;/project.build.sourceEncoding&gt; &lt;project.reporting.outputEncoding&gt;UTF-8&lt;/project.reporting.outputEncoding&gt; &lt;!-- Spring Settings --&gt; &lt;spring-cloud.version&gt;Finchley.RC1&lt;/spring-cloud.version&gt; &lt;/properties&gt; &lt;dependencyManagement&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-dependencies&lt;/artifactId&gt; &lt;version&gt;${spring-cloud.version}&lt;/version&gt; &lt;type&gt;pom&lt;/type&gt; &lt;scope&gt;import&lt;/scope&gt; &lt;/dependency&gt; &lt;/dependencies&gt; &lt;/dependencyManagement&gt; &lt;build&gt; &lt;plugins&gt; &lt;!-- Compiler 插件, 设定 JDK 版本 --&gt; &lt;plugin&gt; &lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt; &lt;artifactId&gt;maven-compiler-plugin&lt;/artifactId&gt; &lt;configuration&gt; &lt;showWarnings&gt;true&lt;/showWarnings&gt; &lt;/configuration&gt; &lt;/plugin&gt; &lt;!-- 打包 jar 文件时，配置 manifest 文件，加入 lib 包的 jar 依赖 --&gt; &lt;plugin&gt; &lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt; &lt;artifactId&gt;maven-jar-plugin&lt;/artifactId&gt; &lt;configuration&gt; &lt;archive&gt; &lt;addMavenDescriptor&gt;false&lt;/addMavenDescriptor&gt; &lt;/archive&gt; &lt;/configuration&gt; &lt;executions&gt; &lt;execution&gt; &lt;configuration&gt; &lt;archive&gt; &lt;manifest&gt; &lt;!-- Add directory entries --&gt; &lt;addDefaultImplementationEntries&gt;true&lt;/addDefaultImplementationEntries&gt; &lt;addDefaultSpecificationEntries&gt;true&lt;/addDefaultSpecificationEntries&gt; &lt;addClasspath&gt;true&lt;/addClasspath&gt; &lt;/manifest&gt; &lt;/archive&gt; &lt;/configuration&gt; &lt;/execution&gt; &lt;/executions&gt; &lt;/plugin&gt; &lt;!-- resource --&gt; &lt;plugin&gt; &lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt; &lt;artifactId&gt;maven-resources-plugin&lt;/artifactId&gt; &lt;/plugin&gt; &lt;!-- install --&gt; &lt;plugin&gt; &lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt; &lt;artifactId&gt;maven-install-plugin&lt;/artifactId&gt; &lt;/plugin&gt; &lt;!-- clean --&gt; &lt;plugin&gt; &lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt; &lt;artifactId&gt;maven-clean-plugin&lt;/artifactId&gt; &lt;/plugin&gt; &lt;!-- ant --&gt; &lt;plugin&gt; &lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt; &lt;artifactId&gt;maven-antrun-plugin&lt;/artifactId&gt; &lt;/plugin&gt; &lt;!-- dependency --&gt; &lt;plugin&gt; &lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt; &lt;artifactId&gt;maven-dependency-plugin&lt;/artifactId&gt; &lt;/plugin&gt; &lt;/plugins&gt; &lt;pluginManagement&gt; &lt;plugins&gt; &lt;!-- Java Document Generate --&gt; &lt;plugin&gt; &lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt; &lt;artifactId&gt;maven-javadoc-plugin&lt;/artifactId&gt; &lt;executions&gt; &lt;execution&gt; &lt;phase&gt;prepare-package&lt;/phase&gt; &lt;goals&gt; &lt;goal&gt;jar&lt;/goal&gt; &lt;/goals&gt; &lt;/execution&gt; &lt;/executions&gt; &lt;/plugin&gt; &lt;!-- YUI Compressor (CSS/JS压缩) --&gt; &lt;plugin&gt; &lt;groupId&gt;net.alchim31.maven&lt;/groupId&gt; &lt;artifactId&gt;yuicompressor-maven-plugin&lt;/artifactId&gt; &lt;version&gt;1.5.1&lt;/version&gt; &lt;executions&gt; &lt;execution&gt; &lt;phase&gt;prepare-package&lt;/phase&gt; &lt;goals&gt; &lt;goal&gt;compress&lt;/goal&gt; &lt;/goals&gt; &lt;/execution&gt; &lt;/executions&gt; &lt;configuration&gt; &lt;encoding&gt;UTF-8&lt;/encoding&gt; &lt;jswarn&gt;false&lt;/jswarn&gt; &lt;nosuffix&gt;true&lt;/nosuffix&gt; &lt;linebreakpos&gt;30000&lt;/linebreakpos&gt; &lt;force&gt;true&lt;/force&gt; &lt;includes&gt; &lt;include&gt;**/*.js&lt;/include&gt; &lt;include&gt;**/*.css&lt;/include&gt; &lt;/includes&gt; &lt;excludes&gt; &lt;exclude&gt;**/*.min.js&lt;/exclude&gt; &lt;exclude&gt;**/*.min.css&lt;/exclude&gt; &lt;/excludes&gt; &lt;/configuration&gt; &lt;/plugin&gt; &lt;/plugins&gt; &lt;/pluginManagement&gt; &lt;!-- 资源文件配置 --&gt; &lt;resources&gt; &lt;resource&gt; &lt;directory&gt;src/main/java&lt;/directory&gt; &lt;excludes&gt; &lt;exclude&gt;**/*.java&lt;/exclude&gt; &lt;/excludes&gt; &lt;/resource&gt; &lt;resource&gt; &lt;directory&gt;src/main/resources&lt;/directory&gt; &lt;/resource&gt; &lt;/resources&gt; &lt;/build&gt; &lt;repositories&gt; &lt;repository&gt; &lt;id&gt;aliyun-repos&lt;/id&gt; &lt;name&gt;Aliyun Repository&lt;/name&gt; &lt;url&gt;http://maven.aliyun.com/nexus/content/groups/public&lt;/url&gt; &lt;releases&gt; &lt;enabled&gt;true&lt;/enabled&gt; &lt;/releases&gt; &lt;snapshots&gt; &lt;enabled&gt;false&lt;/enabled&gt; &lt;/snapshots&gt; &lt;/repository&gt; &lt;repository&gt; &lt;id&gt;sonatype-repos&lt;/id&gt; &lt;name&gt;Sonatype Repository&lt;/name&gt; &lt;url&gt;https://oss.sonatype.org/content/groups/public&lt;/url&gt; &lt;releases&gt; &lt;enabled&gt;true&lt;/enabled&gt; &lt;/releases&gt; &lt;snapshots&gt; &lt;enabled&gt;false&lt;/enabled&gt; &lt;/snapshots&gt; &lt;/repository&gt; &lt;repository&gt; &lt;id&gt;sonatype-repos-s&lt;/id&gt; &lt;name&gt;Sonatype Repository&lt;/name&gt; &lt;url&gt;https://oss.sonatype.org/content/repositories/snapshots&lt;/url&gt; &lt;releases&gt; &lt;enabled&gt;false&lt;/enabled&gt; &lt;/releases&gt; &lt;snapshots&gt; &lt;enabled&gt;true&lt;/enabled&gt; &lt;/snapshots&gt; &lt;/repository&gt; &lt;repository&gt; &lt;id&gt;spring-snapshots&lt;/id&gt; &lt;name&gt;Spring Snapshots&lt;/name&gt; &lt;url&gt;https://repo.spring.io/snapshot&lt;/url&gt; &lt;snapshots&gt; &lt;enabled&gt;true&lt;/enabled&gt; &lt;/snapshots&gt; &lt;/repository&gt; &lt;repository&gt; &lt;id&gt;spring-milestones&lt;/id&gt; &lt;name&gt;Spring Milestones&lt;/name&gt; &lt;url&gt;https://repo.spring.io/milestone&lt;/url&gt; &lt;snapshots&gt; &lt;enabled&gt;false&lt;/enabled&gt; &lt;/snapshots&gt; &lt;/repository&gt; &lt;/repositories&gt; &lt;pluginRepositories&gt; &lt;pluginRepository&gt; &lt;id&gt;aliyun-repos&lt;/id&gt; &lt;name&gt;Aliyun Repository&lt;/name&gt; &lt;url&gt;http://maven.aliyun.com/nexus/content/groups/public&lt;/url&gt; &lt;releases&gt; &lt;enabled&gt;true&lt;/enabled&gt; &lt;/releases&gt; &lt;snapshots&gt; &lt;enabled&gt;false&lt;/enabled&gt; &lt;/snapshots&gt; &lt;/pluginRepository&gt; &lt;/pluginRepositories&gt; &lt;/project&gt; parent：继承了 Spring Boot 的 Parent，表示我们是一个 Spring Boot 工程 package：pom，表示该项目仅当做依赖项目，没有具体的实现代码 spring-cloud-dependencies：在 properties 配置中预定义了版本号为 Finchley.RC1 ，表示我们的 Spring Cloud 使用的是 F 版 build：配置了项目所需的各种插件 repositories：配置项目下载依赖时的第三方库 在实际开发中，我们所有的项目都会依赖这个 dependencies 项目，整个项目周期中的所有第三方依赖的版本也都由该项目进行管理。 【服务注册与发现】我们需要用的组件是 Spring Cloud Netflix 的Eureka，Eureka 是一个服务注册和发现模块 POM&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt; &lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;parent&gt; &lt;groupId&gt;com.yan&lt;/groupId&gt; &lt;artifactId&gt;hello-spring-cloud-dependencies&lt;/artifactId&gt; &lt;version&gt;1.0.0-SNAPSHOT&lt;/version&gt; &lt;relativePath&gt;../hello-spring-cloud-dependencies/pom.xml&lt;/relativePath&gt; &lt;/parent&gt; &lt;artifactId&gt;hello-spring-cloud-eureka&lt;/artifactId&gt; &lt;packaging&gt;jar&lt;/packaging&gt; &lt;dependencies&gt; &lt;!-- Spring Boot Begin --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;/dependency&gt; &lt;!-- Spring Boot End --&gt; &lt;!-- Spring Cloud Begin --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-netflix-eureka-server&lt;/artifactId&gt; &lt;/dependency&gt; &lt;!-- Spring Cloud End --&gt; &lt;/dependencies&gt; &lt;build&gt; &lt;plugins&gt; &lt;plugin&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt; &lt;configuration&gt; &lt;mainClass&gt;com.yan.hello.spring.cloud.eureka.EurekaApplication&lt;/mainClass&gt; &lt;/configuration&gt; &lt;/plugin&gt; &lt;/plugins&gt; &lt;/build&gt; &lt;/project&gt; Application启动一个服务注册中心，只需要一个注解 @EnableEurekaServer package com.yan.hello.spring.cloud.eureka; import org.springframework.boot.SpringApplication; import org.springframework.boot.autoconfigure.SpringBootApplication; import org.springframework.cloud.netflix.eureka.server.EnableEurekaServer; @SpringBootApplication @EnableEurekaServer public class EurekaApplication { public static void main(String[] args) { SpringApplication.run(EurekaApplication.class, args); } } application.ymlEureka 是一个高可用的组件，它没有后端缓存，每一个实例注册之后需要向注册中心发送心跳（因此可以在内存中完成），在默认情况下 Erureka Server 也是一个 Eureka Client ,必须要指定一个 Server。 spring: application: name: hello-spring-cloud-eureka server: port: 8761 eureka: instance: hostname: localhost client: registerWithEureka: false fetchRegistry: false serviceUrl: defaultZone: http://${eureka.instance.hostname}:${server.port}/eureka/ 通过 eureka.client.registerWithEureka:false 和 fetchRegistry:false 来表明自己是一个 Eureka Server. 【创建服务提供者】POM&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt; &lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;parent&gt; &lt;groupId&gt;com.yan&lt;/groupId&gt; &lt;artifactId&gt;hello-spring-cloud-dependencies&lt;/artifactId&gt; &lt;version&gt;1.0.0-SNAPSHOT&lt;/version&gt; &lt;relativePath&gt;../hello-spring-cloud-dependencies/pom.xml&lt;/relativePath&gt; &lt;/parent&gt; &lt;artifactId&gt;hello-spring-cloud-service-admin&lt;/artifactId&gt; &lt;packaging&gt;jar&lt;/packaging&gt; &lt;dependencies&gt; &lt;!-- Spring Boot Begin --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;/dependency&gt; &lt;!-- Spring Boot End --&gt; &lt;!-- Spring Cloud Begin --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-netflix-eureka-server&lt;/artifactId&gt; &lt;/dependency&gt; &lt;!-- Spring Cloud End --&gt; &lt;/dependencies&gt; &lt;build&gt; &lt;plugins&gt; &lt;plugin&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt; &lt;configuration&gt; &lt;mainClass&gt;com.yan.hello.spring.cloud.service.admin.ServiceAdminApplication&lt;/mainClass&gt; &lt;/configuration&gt; &lt;/plugin&gt; &lt;/plugins&gt; &lt;/build&gt; &lt;/project&gt; Application通过注解 @EnableEurekaClient 表明自己是一个 Eureka Client. package com.yan.hello.spring.cloud.service.admin; import org.springframework.boot.SpringApplication; import org.springframework.boot.autoconfigure.SpringBootApplication; import org.springframework.cloud.netflix.eureka.EnableEurekaClient; @SpringBootApplication @EnableEurekaClient public class ServiceAdminApplication { public static void main(String[] args) { SpringApplication.run(ServiceAdminApplication.class, args); } } application.ymlspring: application: name: hello-spring-cloud-service-admin server: port: 8762 eureka: client: serviceUrl: defaultZone: http://localhost:8761/eureka/ Controllerpackage com.yan.hello.spring.cloud.service.admin.controller; import org.springframework.beans.factory.annotation.Value; import org.springframework.web.bind.annotation.RequestMapping; import org.springframework.web.bind.annotation.RequestMethod; import org.springframework.web.bind.annotation.RequestParam; import org.springframework.web.bind.annotation.RestController; @RestController public class AdminController { @Value(&quot;${server.port}&quot;) private String port; @GettMapping(&quot;/hi&quot;) public String sayHi(@RequestParam(value = &quot;message&quot;) String message) { return String.format(&quot;Hi，your message is : %s i am from port : %s&quot;, message, port); } } 【 创建服务消费者（Feign）】Feign简介Feign 是一个声明式的伪 Http 客户端，它使得写 Http 客户端变得更简单。使用 Feign，只需要创建一个接口并注解。 POM&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt; &lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;parent&gt; &lt;groupId&gt;com.yan&lt;/groupId&gt; &lt;artifactId&gt;hello-spring-cloud-dependencies&lt;/artifactId&gt; &lt;version&gt;1.0.0-SNAPSHOT&lt;/version&gt; &lt;relativePath&gt;../hello-spring-cloud-dependencies/pom.xml&lt;/relativePath&gt; &lt;/parent&gt; &lt;artifactId&gt;hello-spring-cloud-web-admin-feign&lt;/artifactId&gt; &lt;packaging&gt;jar&lt;/packaging&gt; &lt;dependencies&gt; &lt;!-- Spring Boot Begin --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-tomcat&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-thymeleaf&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-actuator&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;/dependency&gt; &lt;!-- Spring Boot End --&gt; &lt;!-- Spring Cloud Begin --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-netflix-eureka-server&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-openfeign&lt;/artifactId&gt; &lt;/dependency&gt; &lt;!-- Spring Cloud End --&gt; &lt;!-- 解决 thymeleaf 模板引擎一定要执行严格的 html5 格式校验问题 --&gt; &lt;dependency&gt; &lt;groupId&gt;net.sourceforge.nekohtml&lt;/groupId&gt; &lt;artifactId&gt;nekohtml&lt;/artifactId&gt; &lt;/dependency&gt; &lt;/dependencies&gt; &lt;build&gt; &lt;plugins&gt; &lt;plugin&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt; &lt;configuration&gt; &lt;mainClass&gt;com.yan.hello.spring.cloud.web.admin.feign.WebAdminFeignApplication&lt;/mainClass&gt; &lt;/configuration&gt; &lt;/plugin&gt; &lt;/plugins&gt; &lt;/build&gt; &lt;/project&gt; Application通过 @EnableFeignClients 注解开启 Feign 功能 package com.yan.hello.spring.cloud.web.admin.feign; import org.springframework.boot.SpringApplication; import org.springframework.boot.autoconfigure.SpringBootApplication; import org.springframework.cloud.client.discovery.EnableDiscoveryClient; import org.springframework.cloud.openfeign.EnableFeignClients; @SpringBootApplication @EnableDiscoveryClient @EnableFeignClients public class WebAdminFeignApplication { public static void main(String[] args) { SpringApplication.run(WebAdminFeignApplication.class, args); } } application.ymlspring: application: name: hello-spring-cloud-web-admin-feign thymeleaf: cache: false mode: LEGACYHTML5 encoding: UTF-8 servlet: content-type: text/html server: port: 8765 eureka: client: serviceUrl: defaultZone: http://localhost:8761/eureka/ Configuration配置注入 RestTemplate 的 Bean，并通过 @LoadBalanced 注解表明开启负载均衡功能 package com.yan.hello.spring.cloud.web.admin.ribbon.config; import org.springframework.cloud.client.loadbalancer.LoadBalanced; import org.springframework.context.annotation.Bean; import org.springframework.context.annotation.Configuration; import org.springframework.web.client.RestTemplate; @Configuration public class RestTemplateConfiguration { @Bean @LoadBalanced public RestTemplate restTemplate() { return new RestTemplate(); } } 创建测试用的 接口和Controllerpackage com.yan.hello.spring.cloud.web.admin.feign.service; import org.springframework.cloud.openfeign.FeignClient; import org.springframework.web.bind.annotation.RequestMapping; import org.springframework.web.bind.annotation.RequestMethod; import org.springframework.web.bind.annotation.RequestParam; @FeignClient(value = &quot;hello-spring-cloud-service-admin&quot;) public interface AdminService { @RequestMapping(value = &quot;hi&quot;, method = RequestMethod.GET) public String sayHi(@RequestParam(value = &quot;message&quot;) String message); } package com.yan.hello.spring.cloud.web.admin.feign.controller; import com.yan.hello.spring.cloud.web.admin.feign.service.AdminService; import org.springframework.beans.factory.annotation.Autowired; import org.springframework.web.bind.annotation.RequestMapping; import org.springframework.web.bind.annotation.RequestMethod; import org.springframework.web.bind.annotation.RequestParam; import org.springframework.web.bind.annotation.RestController; @RestController public class AdminController { @Autowired private AdminService adminService; @RequestMapping(value = &quot;hi&quot;, method = RequestMethod.GET) public String sayHi(@RequestParam String message) { return adminService.sayHi(message); } } Feign 中使用熔断器Feign 是自带熔断器的，但默认是关闭的。需要在配置文件中配置打开它，在配置文件增加以下代码： feign: hystrix: enabled: true 增加 fallback 指定类package com.yan.hello.spring.cloud.web.admin.feign.service; import com.yan.hello.spring.cloud.web.admin.feign.service.hystrix.AdminServiceHystrix; import org.springframework.cloud.openfeign.FeignClient; import org.springframework.web.bind.annotation.RequestMapping; import org.springframework.web.bind.annotation.RequestMethod; import org.springframework.web.bind.annotation.RequestParam; @FeignClient(value = &quot;hello-spring-cloud-service-admin&quot;, fallback = AdminServiceHystrix.class) public interface AdminService { @RequestMapping(value = &quot;hi&quot;, method = RequestMethod.GET) public String sayHi(@RequestParam(value = &quot;message&quot;) String message); } 创建熔断器类并实现对应的 Feign 接口package com.yan.hello.spring.cloud.web.admin.feign.service.hystrix; import com.yan.hello.spring.cloud.web.admin.feign.service.AdminService; import org.springframework.stereotype.Component; @Component public class AdminServiceHystrix implements AdminService { @Override public String sayHi(String message) { return &quot;Hi，your message is :\\&quot;&quot; + message + &quot;\\&quot; but request error.&quot;; } } 【未完待续…..】","categories":[{"name":"Java","slug":"Java","permalink":"https://www.shuaime.top/categories/Java/"},{"name":"Spring Cloud","slug":"Spring-Cloud","permalink":"https://www.shuaime.top/categories/Spring-Cloud/"}],"tags":[{"name":"Spring Cloud","slug":"Spring-Cloud","permalink":"https://www.shuaime.top/tags/Spring-Cloud/"}],"keywords":[{"name":"Java","slug":"Java","permalink":"https://www.shuaime.top/categories/Java/"},{"name":"Spring Cloud","slug":"Spring-Cloud","permalink":"https://www.shuaime.top/categories/Spring-Cloud/"}]},{"title":"Spring Data JPA","slug":"springdatajpa","date":"2019-11-06T06:17:09.000Z","updated":"2020-03-31T10:03:12.000Z","comments":true,"path":"posts/accb903d/","link":"","permalink":"https://www.shuaime.top/posts/accb903d/","excerpt":"写作时间：2019-11-06 实现目标：Spring Data JPA入门涉及知识：持久层框架","text":"写作时间：2019-11-06 实现目标：Spring Data JPA入门涉及知识：持久层框架 【思维导图】 【Spring Data JPA简介】Spring Data JPA 是 spring data 项目下的一个模块。提供了一套基于 JPA标准操作数据库的简化方案。底层默认的是依赖 Hibernate JPA 来实现的我们只需要定义接口并集成 Spring Data JPA 中所提供的接口就可以了。不需要编写接口实现类。 【依赖与配置数据源】&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-data-jpa&lt;/artifactId&gt; &lt;/dependency&gt; server: port: 8080 servlet: context-path: / spring: datasource: url: jdbc:mysql://localhost:3306/test?useUnicode=true&amp;characterEncoding=UTF-8&amp;zeroDateTimeBehavior=convertToNull&amp;allowMultiQueries=true&amp;useSSL=false username: root password: root jpa: database: MySQL database-platform: org.hibernate.dialect.MySQL5InnoDBDialect show-sql: true hibernate: ddl-auto: update ddl-auto create：每次运行程序时，都会重新创建表，故而数据会丢失 create-drop：每次运行程序时会先创建表结构，然后待程序结束时清空表 upadte：每次运行程序，没有表时会创建表，如果对象发生改变会更新表结构，原有数据不会清空，只会更新（推荐使用） validate：运行程序会校验数据与数据库的字段类型是否相同，字段不同会报错 none: 禁用DDL处理 【CRUD示例】【实体类】import java.io.Serializable; import javax.persistence.Column; import javax.persistence.Entity; import javax.persistence.GeneratedValue; import javax.persistence.GenerationType; import javax.persistence.Id; import javax.persistence.Table; @Entity @Table(name=&quot;t_user&quot;) public class User implements Serializable{ @Id @GeneratedValue(strategy=GenerationType.IDENTITY)//strategy=GenerationType.IDENTITY 自增长 @Column(name=&quot;userid&quot;) private Integer userid; @Column(name=&quot;username&quot;) private String username; @Column(name=&quot;userage&quot;) private Integer userage; public Integer getUserid() { return userid; } public void setUserid(Integer userid) { this.userid = userid; } public String getUsername() { return username; } public void setUsername(String username) { this.username = username; } public Integer getUserage() { return userage; } public void setUserage(Integer userage) { this.userage = userage; } @Override public String toString() { return &quot;User [userid=&quot; + userid + &quot;, username=&quot; + username + &quot;, userage=&quot; + userage + &quot;]&quot;; } } @GenericGenerator是Hibernate提供的主键生成策略注解 TABLE： 使用一个特定的数据库表格来保存主键 SEQUENCE： 根据底层数据库的序列来生成主键，条件是数据库支持序列。这个值要与generator一起使用，generator 指定生成主键使用的生成器（可能是orcale中自己编写的序列） IDENTITY： 主键由数据库自动生成（主要是支持自动增长的数据库，如mysql） AUTO： 主键由程序控制，也是GenerationType的默认值 【JpaRepository接口】package com.example.springbootjpa.repository; import com.example.springbootjpa.entity.User; import org.springframework.data.jpa.repository.JpaRepository; public interface UserRepository extends JpaRepository&lt;User, String&gt; { } 【测试类】@RunWith(SpringJUnit4ClassRunner.class) @ContextConfiguration(&quot;classpath:applicationContext.xml&quot;) public class RepositoryTest { @Autowired private UserRepository userRepository; /** * 查询全部数据 */ @Test public void test1(){ List&lt;User&gt; list = this.userRepository.findAll(); for (User users : list) { System.out.println(users); } } } 【JpaSpecificationExecutor 接口】public interface UsersDao extends JpaRepository&lt;User,Integer&gt;,JpaSpecificationExecutor&lt;User&gt;{ } 【单条件查询】@RunWith(SpringJUnit4ClassRunner.class) @ContextConfiguration(&quot;classpath:applicationContext.xml&quot;) public class RepositoryTest { @Autowired private UsersDao usersDao; /** * 需求：根据用户姓名查询数据 */ @Test public void test1(){ Specification&lt;User&gt; spec = new Specification&lt;User&gt;() { /** * @return Predicate:定义了查询条件 * @param Root&lt;Users&gt; root:根对象。封装了查询条件的对象 * @param CriteriaQuery&lt;?&gt; query:定义了一个基本的查询。一般不使用 * @param CriteriaBuilder cb:创建一个查询条件 */ @Override public Predicate toPredicate(Root&lt;User&gt; root, CriteriaQuery&lt;?&gt; query, CriteriaBuilder cb) { Predicate pre = cb.equal(root.get(&quot;username&quot;), &quot;王五&quot;); return pre; } }; List&lt;User&gt; list = this.usersDao.findAll(spec); for (User users : list) { System.out.println(users); } } } 【多条件查询】 @Test public void test3(){ Specification&lt;User&gt; spec = new Specification&lt;User&gt;() { @Override public Predicate toPredicate(Root&lt;User&gt; root, CriteriaQuery&lt;?&gt; query, CriteriaBuilder cb) { return cb.or(cb.equal(root.get(&quot;username&quot;),&quot;王五&quot;),cb.equal(root.get(&quot;userage&quot;), 25)); } }; List&lt;User&gt; list = this.usersDao.findAll(spec); for (User users : list) { System.out.println(users); } } 【分页与排序】@Test public void test6(){ //排序等定义 Sort sort = new Sort(Direction.DESC,&quot;userid&quot;); //分页的定义 Pageable pageable = new PageRequest(2,2, sort); //查询条件 Specification&lt;User&gt; spec = new Specification&lt;User&gt;() { @Override public Predicate toPredicate(Root&lt;User&gt; root, CriteriaQuery&lt;?&gt; query, CriteriaBuilder cb) { return cb.like(root.get(&quot;username&quot;).as(String.class), &quot;王%&quot;); } }; Page&lt;User&gt; page = this.usersDao.findAll(spec, pageable); System.out.println(&quot;总条数：&quot;+page.getTotalElements()); System.out.println(&quot;总页数：&quot;+page.getTotalPages()); List&lt;User&gt; list = page.getContent(); for (User users : list) { System.out.println(users); } } 【未完待续…..】","categories":[{"name":"Java","slug":"Java","permalink":"https://www.shuaime.top/categories/Java/"},{"name":"Spring Boot","slug":"Spring-Boot","permalink":"https://www.shuaime.top/categories/Spring-Boot/"}],"tags":[{"name":"Spring","slug":"Spring","permalink":"https://www.shuaime.top/tags/Spring/"},{"name":"Spring Data JPA","slug":"Spring-Data-JPA","permalink":"https://www.shuaime.top/tags/Spring-Data-JPA/"}],"keywords":[{"name":"Java","slug":"Java","permalink":"https://www.shuaime.top/categories/Java/"},{"name":"Spring Boot","slug":"Spring-Boot","permalink":"https://www.shuaime.top/categories/Spring-Boot/"}]},{"title":"Intellij IDEA破解","slug":"Intellij-IDEA","date":"2019-11-01T04:56:14.000Z","updated":"2020-03-30T12:38:07.036Z","comments":true,"path":"posts/db30a45/","link":"","permalink":"https://www.shuaime.top/posts/db30a45/","excerpt":"下载地址： www.ddooo.com/softdown/127550.htm","text":"下载地址： www.ddooo.com/softdown/127550.htm 选择Active code 把下载好的JetbrainsCrack-3.1-release-enc.jar 文件放在之前安装好的idea的bin目录下 在两个文件的用Notepad++或者用记事本打开这两个文件，都写上-javaagent:D:\\Intellij IDEA2018.2.2\\bin\\JetbrainsCrack-3.1-release-enc.jar，也就是刚才你放JetbrainsCrack-3.1-release-enc.jar的地址,然后在Active code输入破解码 破解完成后截图","categories":[{"name":"IDEA","slug":"IDEA","permalink":"https://www.shuaime.top/categories/IDEA/"}],"tags":[{"name":"IDEA","slug":"IDEA","permalink":"https://www.shuaime.top/tags/IDEA/"},{"name":"工具","slug":"工具","permalink":"https://www.shuaime.top/tags/工具/"}],"keywords":[{"name":"IDEA","slug":"IDEA","permalink":"https://www.shuaime.top/categories/IDEA/"}]},{"title":"MySQL保存emoji表情","slug":"mysql保存表情","date":"2019-10-30T01:38:18.000Z","updated":"2020-03-30T13:03:03.920Z","comments":true,"path":"posts/4bb9769b/","link":"","permalink":"https://www.shuaime.top/posts/4bb9769b/","excerpt":"MySQL也可以保存 表情","text":"MySQL也可以保存 表情 在MySQL中的 utf8 最多支持的是3个字节，而我们要保存的emoji表情是4个字节，所以就保存不到数据库里面 所以只要更改字符编码即可 认识 utf8md4MySQL在5.5.3之后增加了这个utf8mb4的编码，mb4就是most bytes 4的意思，它专门用来兼容四字节的unicode 解决方案MySQL 配置文件修改找到MySQL路径下的my.ini或者default.ini [mysql] default-character-set=utf8mb4 [mysqld] character-set-server=utf8mb4 修改 数据库的字符集,改表的字符集 和 对应字段的字符集为utf8mb4 spring.datasource.url=jdbc:mysql://localhost:3306/test?characterEncoding=utf8&amp;characterSetResults=utf8&amp;autoReconnect=true&amp;failOverReadOnly=false 在项目中往往都会加上 characterEncoding=utf8 , 如果还不能保存emoji表情，这里也去掉","categories":[{"name":"MySQL","slug":"MySQL","permalink":"https://www.shuaime.top/categories/MySQL/"}],"tags":[{"name":"MySQL","slug":"MySQL","permalink":"https://www.shuaime.top/tags/MySQL/"}],"keywords":[{"name":"MySQL","slug":"MySQL","permalink":"https://www.shuaime.top/categories/MySQL/"}]},{"title":"Spring Security","slug":"Spring-Security","date":"2019-10-25T12:14:39.000Z","updated":"2020-03-31T10:02:54.761Z","comments":true,"path":"posts/27ace9d5/","link":"","permalink":"https://www.shuaime.top/posts/27ace9d5/","excerpt":"写作时间：2019-10-25实现目标：Spring Security的使用涉及知识：安全管理框架","text":"写作时间：2019-10-25实现目标：Spring Security的使用涉及知识：安全管理框架 【思维导图】 【Spring Security简介】Spring Security是 Spring家族中的一个安全管理框架，实际上，在 Spring Boot出现之前，Spring Security 就已经发展了多年了，但是使用的并不多，安全管理这个领域，一直是 Shiro的天下。相对于 Shiro，在SSM/SSH中整合 Spring Security都是比较麻烦的操作，所以，Spring Security虽然功能比 Shiro 强大，但是使用反而没有 Shiro 多（Shiro 虽然功能没有 Spring Security多，但是对于大部分项目而言，Shiro也够用了）。自从有了 Spring Boot之后，Spring Boot对于Spring Security提供了 自动化配置方案，可以零配置使用 Spring Security。 【核心功能】认证 授权 攻击防护 【入门项目】首先创建spring boot项目 pom.xml 中的 Spring Security 依赖： &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-security&lt;/artifactId&gt; &lt;/dependency&gt; 【application.yml】spring: thymeleaf: mode: HTML5 encoding: UTF-8 cache: false datasource: driver-class-name: com.mysql.cj.jdbc.Driver url: jdbc:mysql://localhost:3306/spring-security?useUnicode=true&amp;characterEncoding=utf-8&amp;useSSL=false username: root password: root 【User】User类实现了 UserDetails接口，该接口是实现Spring Security 认证信息的核心接口。其中 getUsername方法为 UserDetails 接口 的方法，这个方法返回username，也可以是其他的用户信息，例如手机号、邮箱等。getAuthorities()方法返回的是该用户设置的权限信息，在本实例中，从数据库取出用户的所有角色信息，权限信息也可以是用户的其他信息，不一定是角色信息。另外需要读取密码，最后几个方法一般情况下都返回 true，也可以根据自己的需求进行业务判断 public class User implements UserDetails , Serializable { private Long id; private String username; private String password; private List&lt;Role&gt; authorities; public Long getId() { return id; } public void setId(Long id) { this.id = id; } @Override public String getUsername() { return username; } public void setUsername(String username) { this.username = username; } @Override public String getPassword() { return password; } public void setPassword(String password) { this.password = password; } @Override public List&lt;Role&gt; getAuthorities() { return authorities; } public void setAuthorities(List&lt;Role&gt; authorities) { this.authorities = authorities; } /** * 用户账号是否过期 */ @Override public boolean isAccountNonExpired() { return true; } /** * 用户账号是否被锁定 */ @Override public boolean isAccountNonLocked() { return true; } /** * 用户密码是否过期 */ @Override public boolean isCredentialsNonExpired() { return true; } /** * 用户是否可用 */ @Override public boolean isEnabled() { return true; } } 【Role】Role 类实现了 GrantedAuthority 接口，并重写 getAuthority() 方法。权限点可以为任何字符串，不一定非要用角色名 public class Role implements GrantedAuthority { private Long id; private String name; public Long getId() { return id; } public void setId(Long id) { this.id = id; } public String getName() { return name; } public void setName(String name) { this.name = name; } @Override public String getAuthority() { return name; } } 【MyUserDetailsService】Service 层需要实现 UserDetailsService 接口，该接口是根据用户名获取该用户的所有信息， 包括用户信息和权限点 @Service public class MyUserDetailsService implements UserDetailsService { @Autowired private UserMapper userMapper; @Autowired private RoleMapper roleMapper; @Override public UserDetails loadUserByUsername(String userName) throws UsernameNotFoundException { User user = userMapper.loadUserByUsername( userName ); if (null != user) { List&lt;Role&gt; roles = roleMapper.getRolesByUserId( user.getId() ); user.setAuthorities( roles ); } return user; } } 【未完待续…..】","categories":[{"name":"Java","slug":"Java","permalink":"https://www.shuaime.top/categories/Java/"},{"name":"Spring Boot","slug":"Spring-Boot","permalink":"https://www.shuaime.top/categories/Spring-Boot/"}],"tags":[{"name":"Spring","slug":"Spring","permalink":"https://www.shuaime.top/tags/Spring/"},{"name":"Spring Security","slug":"Spring-Security","permalink":"https://www.shuaime.top/tags/Spring-Security/"}],"keywords":[{"name":"Java","slug":"Java","permalink":"https://www.shuaime.top/categories/Java/"},{"name":"Spring Boot","slug":"Spring-Boot","permalink":"https://www.shuaime.top/categories/Spring-Boot/"}]},{"title":"AngularJS","slug":"AngularJS","date":"2019-10-23T09:40:56.000Z","updated":"2020-03-30T12:58:56.217Z","comments":true,"path":"posts/8fa64eaf/","link":"","permalink":"https://www.shuaime.top/posts/8fa64eaf/","excerpt":"写作时间：2019-10-23实现目标：AngularJS基础入门涉及知识：AngularJS","text":"写作时间：2019-10-23实现目标：AngularJS基础入门涉及知识：AngularJS 【AngularJS简介】AngularJS是一个创建富客户端应用的JavaScript MVC框架。你仍然需要具有服务端后台，但大多数的用户交互逻辑将放到客户端上处理。它可以创建单页的应用程序，一个页面的应用仅仅需要HTML,CSS和JavaScript在客户端。它的目标是增强页面的模型-视图-控制（MVC）的功能，为简化开发和测试。单页Web应用（single page web application，SPA），就是只有一张Web页面的应用。浏览器一开始会加载必需的HTML、CSS和JavaScript，所有的操作都在这张页面上完成，由JavaScript来控制不同view在这个页面上的呈现。 【常用指令】【ng-app】声明AngularJS所管辖的区域。一般写在body或者html标签上，原则上一个页面只能有一个 &lt;body ng-app=&quot;myApp&quot;&gt;&lt;/body&gt; 【ng-model】把元素值（比如输入域的值）绑定到应用程序的变量中 &lt;input type=&quot;text&quot; ng-model=&quot;name&quot;/&gt; 【ng-init】初始化AngularJS应用程序中的变量值 &lt;body ng-app=&quot;&quot; ng-init=&quot;name=&#39;NAME&#39;&quot;&gt; 【ng-bind】把应用程序变量中的值，输出到页面HTML视图中，可以与表达式{ { } }互相替换 &lt;p ng-bind=&quot;5+5+&#39;Angular&#39;&quot;&gt;&lt;/p&gt; 【表达式】AngularJS使用{ { } }绑定表达式。用于将表达式的内容输出到页面中。表达式中可以是文字、运算符、变量等，也可以在表达式中进行运算输出结果 &lt;p&gt;{{5+5+\"Angular\"}}&lt;/p&gt; &lt;p ng-bind=&quot;5+5+&#39;Angular&#39;&quot;&gt;&lt;/p&gt; 【MVC与作用域】&lt;div ng-app=&quot;myApp&quot; ng-controller=&quot;myCtrl&quot;&gt; 名: &lt;input type=&quot;text&quot; ng-model=&quot;firstName&quot;&gt;&lt;br&gt; 姓: &lt;input type=&quot;text&quot; ng-model=&quot;lastName&quot;&gt;&lt;br&gt; &lt;br&gt; 姓名: {{firstName + \" \" + lastName}} &lt;/div&gt; &lt;script&gt; var app = angular.module(&#39;myApp&#39;, []); app.controller(&#39;myCtrl&#39;, function($scope) { $scope.firstName= &quot;John&quot;; $scope.lastName= &quot;Doe&quot;; }); &lt;/script&gt; Model(模型层)：应用程序中用于处理数据的部分，(包括将数据保存或者修改到数据库、变量、文件中)在AngularJS中，Model特指的是：应用程序中的各种数据View(视图层)：用户可以看到的用户显示数据的页面Controller(控制器):控制器是连接View和Model的桥梁，负责从View读取数据，接受用户的操作输入；并将数据发送给Model层 【Controller】在AngularJS的模块上，创建一个控制器，需要传入两个参数 var app = angular.module(&#39;myApp&#39;, []); app.controller(&#39;myCtrl&#39;, function($scope) { }); 【作用域】$scope局部作用域，声明在$scope上的属性和方法。只能在当前controller使用。 $rootScope根作用域。声明在$rootScope上的属性和方法，可以在整个ng-app所包含的范围使用。 【Service】$location:返回当前页面的URL地址信息，是一个对象 var app = angular.module(&#39;myApp&#39;, []); app.controller(&#39;customersCtrl&#39;, function($scope, $location) { $scope.myUrl = $location.absUrl(); }); $http:向服务器发送请求，类似于JQuery中的Ajax var app = angular.module(&#39;myApp&#39;, []); app.controller(&#39;siteCtrl&#39;, function($scope, $http) { $http({ method: &#39;GET&#39;, url: &#39;&#39; }).then(function successCallback(response) { $scope.names = response.data.sites; }, function errorCallback(response) { // 请求失败执行代码 }); }); 【未完待续…..】","categories":[{"name":"前端","slug":"前端","permalink":"https://www.shuaime.top/categories/前端/"}],"tags":[{"name":"AngularJS","slug":"AngularJS","permalink":"https://www.shuaime.top/tags/AngularJS/"},{"name":"前端","slug":"前端","permalink":"https://www.shuaime.top/tags/前端/"}],"keywords":[{"name":"前端","slug":"前端","permalink":"https://www.shuaime.top/categories/前端/"}]},{"title":"Docker容器化","slug":"docker","date":"2019-10-20T10:38:36.000Z","updated":"2020-03-26T13:51:54.137Z","comments":true,"path":"posts/3d6301c1/","link":"","permalink":"https://www.shuaime.top/posts/3d6301c1/","excerpt":"","text":"1 Docker简介1.1 什么是虚拟化​ 在计算机中，虚拟化（英语：Virtualization）是一种资源管理技术，是将计算机的各种实体资源，如服务器、网络、内存及存储等，予以抽象、转换后呈现出来，打破实体结构间的不可切割的障碍，使用户可以比原本的组态更好的方式来应用这些资源。这些资源的新虚拟部份是不受现有资源的架设方式，地域或物理组态所限制。一般所指的虚拟化资源包括计算能力和资料存储。 ​ 在实际的生产环境中，虚拟化技术主要用来解决高性能的物理硬件产能过剩和老的旧的硬件产能过低的重组重用，透明化底层物理硬件，从而最大化的利用物理硬件 对资源充分利用 ​ 虚拟化技术种类很多，例如：软件虚拟化、硬件虚拟化、内存虚拟化、网络虚拟化(vip)、桌面虚拟化、服务虚拟化、虚拟机等等。 1.2 什么是Docker​ Docker 是一个开源项目，诞生于 2013 年初，最初是 dotCloud 公司内部的一个业余项目。它基于 Google 公司推出的 Go 语言实现。 项目后来加入了 Linux 基金会，遵从了 Apache 2.0 协议，项目代码在 GitHub 上进行维护。 ​ Docker 自开源后受到广泛的关注和讨论，以至于 dotCloud 公司后来都改名为 Docker Inc。Redhat 已经在其 RHEL6.5 中集中支持 Docker；Google 也在其 PaaS 产品中广泛应用。 ​ Docker 项目的目标是实现轻量级的操作系统虚拟化解决方案。 Docker 的基础是 Linux 容器（LXC）等技术。 ​ 在 LXC 的基础上 Docker 进行了进一步的封装，让用户不需要去关心容器的管理，使得操作更为简便。用户操作 Docker 的容器就像操作一个快速轻量级的虚拟机一样简单。 为什么选择Docker? （1）上手快。 ​ 用户只需要几分钟，就可以把自己的程序“Docker化”。Docker依赖于“写时复制”（copy-on-write）模型，使修改应用程序也非常迅速，可以说达到“随心所致，代码即改”的境界。 随后，就可以创建容器来运行应用程序了。大多数Docker容器只需要不到1秒中即可启动。由于去除了管理程序的开销，Docker容器拥有很高的性能，同时同一台宿主机中也可以运行更多的容器，使用户尽可能的充分利用系统资源。 （2）职责的逻辑分类 ​ 使用Docker，开发人员只需要关心容器中运行的应用程序，而运维人员只需要关心如何管理容器。Docker设计的目的就是要加强开发人员写代码的开发环境与应用程序要部署的生产环境一致性。从而降低那种“开发时一切正常，肯定是运维的问题（测试环境都是正常的，上线后出了问题就归结为肯定是运维的问题）” （3）快速高效的开发生命周期 ​ Docker的目标之一就是缩短代码从开发、测试到部署、上线运行的周期，让你的应用程序具备可移植性，易于构建，并易于协作。（通俗一点说，Docker就像一个盒子，里面可以装很多物件，如果需要这些物件的可以直接将该大盒子拿走，而不需要从该盒子中一件件的取。） （4）鼓励使用面向服务的架构 ​ Docker还鼓励面向服务的体系结构和微服务架构。Docker推荐单个容器只运行一个应用程序或进程，这样就形成了一个分布式的应用程序模型，在这种模型下，应用程序或者服务都可以表示为一系列内部互联的容器，从而使分布式部署应用程序，扩展或调试应用程序都变得非常简单，同时也提高了程序的内省性。（当然，可以在一个容器中运行多个应用程序） 1.3 容器与虚拟机比较​ 下面的图片比较了 Docker 和传统虚拟化方式的不同之处，可见容器是在操作系统层面上实现虚拟化，直接复用本地主机的操作系统，而传统方式则是在硬件层面实现。 与传统的虚拟机相比，Docker优势体现为启动速度快、占用体积小。 1.4 Docker 组件1.4.1 Docker服务器与客户端​ Docker是一个客户端-服务器（C/S）架构程序。Docker客户端只需要向Docker服务器或者守护进程发出请求，服务器或者守护进程将完成所有工作并返回结果。Docker提供了一个命令行工具Docker以及一整套RESTful API。你可以在同一台宿主机上运行Docker守护进程和客户端，也可以从本地的Docker客户端连接到运行在另一台宿主机上的远程Docker守护进程。 1.4.2 Docker镜像与容器​ 镜像是构建Docker的基石。用户基于镜像来运行自己的容器。镜像也是Docker生命周期中的“构建”部分。镜像是基于联合文件系统的一种层式结构，由一系列指令一步一步构建出来。例如： 添加一个文件； 执行一个命令； 打开一个窗口。 也可以将镜像当作容器的“源代码”。镜像体积很小，非常“便携”，易于分享、存储和更新。 ​ Docker可以帮助你构建和部署容器，你只需要把自己的应用程序或者服务打包放进容器即可。容器是基于镜像启动起来的，容器中可以运行一个或多个进程。我们可以认为，镜像是Docker生命周期中的构建或者打包阶段，而容器则是启动或者执行阶段。 容器基于镜像启动，一旦容器启动完成后，我们就可以登录到容器中安装自己需要的软件或者服务。 所以Docker容器就是： ​ 一个镜像格式； ​ 一些列标准操作； ​ 一个执行环境。 ​ Docker借鉴了标准集装箱的概念。标准集装箱将货物运往世界各地，Docker将这个模型运用到自己的设计中，唯一不同的是：集装箱运输货物，而Docker运输软件。 和集装箱一样，Docker在执行上述操作时，并不关心容器中到底装了什么，它不管是web服务器，还是数据库，或者是应用程序服务器什么的。所有的容器都按照相同的方式将内容“装载”进去。 Docker也不关心你要把容器运到何方：我们可以在自己的笔记本中构建容器，上传到Registry，然后下载到一个物理的或者虚拟的服务器来测试，在把容器部署到具体的主机中。像标准集装箱一样，Docker容器方便替换，可以叠加，易于分发，并且尽量通用。 1.4.3 Registry（注册中心）​ Docker用Registry来保存用户构建的镜像。Registry分为公共和私有两种。Docker公司运营公共的Registry叫做Docker Hub。用户可以在Docker Hub注册账号，分享并保存自己的镜像（说明：在Docker Hub下载镜像巨慢，可以自己构建私有的Registry）。 ​ https://hub.docker.com/ 2 Docker安装与启动2.1 安装Docker​ Docker官方建议在Ubuntu中安装，因为Docker是基于Ubuntu发布的，而且一般Docker出现的问题Ubuntu是最先更新或者打补丁的。在很多版本的CentOS中是不支持更新最新的一些补丁包的。 ​ 由于我们学习的环境都使用的是CentOS，因此这里我们将Docker安装到CentOS上。注意：这里建议安装在CentOS7.x以上的版本，在CentOS6.x的版本中，安装前需要安装其他很多的环境而且Docker很多补丁不支持更新。 ​ 请直接挂载课程配套的Centos7.x镜像 （1）yum 包更新到最新 sudo yum update （2）安装需要的软件包， yum-util 提供yum-config-manager功能，另外两个是devicemapper驱动依赖的 sudo yum install -y yum-utils device-mapper-persistent-data lvm2 （3）设置yum源为阿里云 sudo yum-config-manager --add-repo http://mirrors.aliyun.com/docker-ce/linux/centos/docker-ce.repo （4）安装docker sudo yum install docker-ce （5）安装后查看docker版本 docker -v 2.2 设置ustc的镜像ustc是老牌的linux镜像服务提供者了，还在遥远的ubuntu 5.04版本的时候就在用。ustc的docker镜像加速器速度很快。ustc docker mirror的优势之一就是不需要注册，是真正的公共服务。 https://lug.ustc.edu.cn/wiki/mirrors/help/docker 编辑该文件： vi /etc/docker/daemon.json 在该文件中输入如下内容： { &quot;registry-mirrors&quot;: [&quot;https://docker.mirrors.ustc.edu.cn&quot;] } 2.3 Docker的启动与停止systemctl命令是系统服务管理器指令 启动docker： systemctl start docker 停止docker： systemctl stop docker 重启docker： systemctl restart docker 查看docker状态： systemctl status docker 开机启动： systemctl enable docker 查看docker概要信息 docker info 查看docker帮助文档 docker --help 3 常用命令3.1 镜像相关命令3.1.1 查看镜像docker images REPOSITORY：镜像名称 TAG：镜像标签 IMAGE ID：镜像ID CREATED：镜像的创建日期（不是获取该镜像的日期） SIZE：镜像大小 这些镜像都是存储在Docker宿主机的/var/lib/docker目录下 3.1.2 搜索镜像如果你需要从网络中查找需要的镜像，可以通过以下命令搜索 docker search 镜像名称 NAME：仓库名称 DESCRIPTION：镜像描述 STARS：用户评价，反应一个镜像的受欢迎程度 OFFICIAL：是否官方 AUTOMATED：自动构建，表示该镜像由Docker Hub自动构建流程创建的 3.1.3 拉取镜像拉取镜像就是从中央仓库中下载镜像到本地 docker pull 镜像名称 例如，我要下载centos7镜像 docker pull centos:7 3.1.4 删除镜像按镜像ID删除镜像 docker rmi 镜像ID 删除所有镜像 docker rmi `docker images -q` 3.2 容器相关命令3.2.1 查看容器查看正在运行的容器 docker ps 查看所有容器 docker ps –a 查看最后一次运行的容器 docker ps –l 查看停止的容器 docker ps -f status=exited 3.2.2 创建与启动容器创建容器常用的参数说明： 创建容器命令：docker run -i：表示运行容器 -t：表示容器启动后会进入其命令行。加入这两个参数后，容器创建就能登录进去。即分配一个伪终端。 –name :为创建的容器命名。 -v：表示目录映射关系（前者是宿主机目录，后者是映射到宿主机上的目录），可以使用多个－v做多个目录或文件映射。注意：最好做目录映射，在宿主机上做修改，然后共享到容器上。 -d：在run后面加上-d参数,则会创建一个守护式容器在后台运行（这样创建容器后不会自动登录容器，如果只加-i -t两个参数，创建后就会自动进去容器）。 -p：表示端口映射，前者是宿主机端口，后者是容器内的映射端口。可以使用多个-p做多个端口映射 （1）交互式方式创建容器 docker run -it --name=容器名称 镜像名称:标签 /bin/bash 这时我们通过ps命令查看，发现可以看到启动的容器，状态为启动状态 退出当前容器 exit （2）守护式方式创建容器： docker run -di --name=容器名称 镜像名称:标签 登录守护式容器方式： docker exec -it 容器名称 (或者容器ID) /bin/bash 3.2.3 停止与启动容器停止容器： docker stop 容器名称（或者容器ID） 启动容器： docker start 容器名称（或者容器ID） 3.2.4 文件拷贝如果我们需要将文件拷贝到容器内可以使用cp命令 docker cp 需要拷贝的文件或目录 容器名称:容器目录 也可以将文件从容器内拷贝出来 docker cp 容器名称:容器目录 需要拷贝的文件或目录 3.2.5 目录挂载我们可以在创建容器的时候，将宿主机的目录与容器内的目录进行映射，这样我们就可以通过修改宿主机某个目录的文件从而去影响容器。创建容器 添加-v参数 后边为 宿主机目录:容器目录，例如： docker run -di -v /usr/local/myhtml:/usr/local/myhtml --name=mycentos3 centos:7 如果你共享的是多级的目录，可能会出现权限不足的提示。 这是因为CentOS7中的安全模块selinux把权限禁掉了，我们需要添加参数 –privileged=true 来解决挂载的目录没有权限的问题 3.2.6 查看容器IP地址我们可以通过以下命令查看容器运行的各种数据 docker inspect 容器名称（容器ID） 也可以直接执行下面的命令直接输出IP地址 docker inspect --format=&#39;{{.NetworkSettings.IPAddress}}&#39; 容器名称（容器ID） 3.2.7 删除容器删除指定的容器： docker rm 容器名称（容器ID） 4 应用部署4.1 MySQL部署（1）拉取mysql镜像 docker pull centos/mysql-57-centos7 （2）创建容器 docker run -di --name=tensquare_mysql -p 33306:3306 -e MYSQL_ROOT_PASSWORD=123456 mysql -p 代表端口映射，格式为 宿主机映射端口:容器运行端口 -e 代表添加环境变量 MYSQL_ROOT_PASSWORD 是root用户的登陆密码 （3）远程登录mysql 连接宿主机的IP ,指定端口为33306 4.2 tomcat部署（1）拉取镜像 docker pull tomcat:7-jre7 （2）创建容器 创建容器 -p表示地址映射 docker run -di --name=mytomcat -p 9000:8080 -v /usr/local/webapps:/usr/local/tomcat/webapps tomcat:7-jre7 4.3 Nginx部署（1）拉取镜像 docker pull nginx （2）创建Nginx容器 docker run -di --name=mynginx -p 80:80 nginx 4.4 Redis部署（1）拉取镜像 docker pull redis （2）创建容器 docker run -di --name=myredis -p 6379:6379 redis 5 迁移与备份5.1 容器保存为镜像我们可以通过以下命令将容器保存为镜像 docker commit mynginx mynginx_i 5.2 镜像备份我们可以通过以下命令将镜像保存为tar 文件 docker save -o mynginx.tar mynginx_i 5.3 镜像恢复与迁移首先我们先删除掉mynginx_img镜像 然后执行此命令进行恢复 docker load -i mynginx.tar -i 输入的文件 执行后再次查看镜像，可以看到镜像已经恢复 6 Dockerfile6.1 什么是DockerfileDockerfile是由一系列命令和参数构成的脚本，这些命令应用于基础镜像并最终创建一个新的镜像。 1、对于开发人员：可以为开发团队提供一个完全一致的开发环境；2、对于测试人员：可以直接拿开发时所构建的镜像或者通过Dockerfile文件构建一个新的镜像开始工作了；3、对于运维人员：在部署时，可以实现应用的无缝移植。 6.2 常用命令 命令 作用 FROM image_name:tag 定义了使用哪个基础镜像启动构建流程 MAINTAINER user_name 声明镜像的创建者 ENV key value 设置环境变量 (可以写多条) RUN command 是Dockerfile的核心部分(可以写多条) ADD source_dir/file dest_dir/file 将宿主机的文件复制到容器内，如果是一个压缩文件，将会在复制后自动解压 COPY source_dir/file dest_dir/file 和ADD相似，但是如果有压缩文件并不能解压 WORKDIR path_dir 设置工作目录 6.3 使用脚本创建镜像步骤： （1）创建目录 mkdir –p /usr/local/dockerjdk8 （2）下载jdk-8u171-linux-x64.tar.gz并上传到服务器（虚拟机）中的/usr/local/dockerjdk8目录 （3）创建文件Dockerfile vi Dockerfile #依赖镜像名称和ID FROM centos:7 #指定镜像创建者信息 MAINTAINER ITCAST #切换工作目录 WORKDIR /usr RUN mkdir /usr/local/java #ADD 是相对路径jar,把java添加到容器中 ADD jdk-8u171-linux-x64.tar.gz /usr/local/java/ #配置java环境变量 ENV JAVA_HOME /usr/local/java/jdk1.8.0_171 ENV JRE_HOME $JAVA_HOME/jre ENV CLASSPATH $JAVA_HOME/lib/dt.jar:$JAVA_HOME/lib/tools.jar:$JRE_HOME/lib:$CLASSPATH ENV PATH $JAVA_HOME/bin:$PATH （4）执行命令构建镜像 docker build -t=&#39;jdk1.8&#39; . 注意后边的空格和点，不要省略 （5）查看镜像是否建立完成 docker images 7 Docker私有仓库7.1 私有仓库搭建与配置（1）拉取私有仓库镜像（此步省略） docker pull registry （2）启动私有仓库容器 docker run -di --name=registry -p 5000:5000 registry （3）打开浏览器 输入地址http://192.168.184.141:5000/v2/_catalog看到`{&quot;repositories&quot;:[]}` 表示私有仓库搭建成功并且内容为空 （4）修改daemon.json vi /etc/docker/daemon.json 添加以下内容，保存退出。 {&quot;insecure-registries&quot;:[&quot;192.168.184.141:5000&quot;]} 此步用于让 docker信任私有仓库地址 （5）重启docker 服务 systemctl restart docker 7.2 镜像上传至私有仓库（1）标记此镜像为私有仓库的镜像 docker tag jdk1.8 192.168.184.141:5000/jdk1.8 （2）再次启动私服容器 docker start registry （3）上传标记的镜像 docker push 192.168.184.141:5000/jdk1.8","categories":[{"name":"Docker","slug":"Docker","permalink":"https://www.shuaime.top/categories/Docker/"}],"tags":[{"name":"Docker","slug":"Docker","permalink":"https://www.shuaime.top/tags/Docker/"},{"name":"Linux","slug":"Linux","permalink":"https://www.shuaime.top/tags/Linux/"}],"keywords":[{"name":"Docker","slug":"Docker","permalink":"https://www.shuaime.top/categories/Docker/"}]},{"title":"使用 Github Pages 和 Hexo 搭建自己的独立博客","slug":"hexo","date":"2019-10-19T09:00:00.000Z","updated":"2020-03-30T13:14:45.853Z","comments":true,"path":"posts/531cd44d/","link":"","permalink":"https://www.shuaime.top/posts/531cd44d/","excerpt":"自己动手搭建博客","text":"自己动手搭建博客 – Hexo Hexo 是一个快速、简洁且高效的博客框架。Hexo 使用 Markdown（或其他渲染引擎）解析文章，在几秒内，即可利用靓丽的主题生成静态网页。 – 安装 Node.js点击此处访问官网，下载所需相应版本，默认安装可以了 – 安装 Git点击此处访问官网，下载所需相应版本，默认安装可以了 参考网址：《git安装》 《Git配置》 – Hexo 的使用– 安装hexo新建一个文件夹用于存放博客目录(如: D:\\Desktop\\blog) 进入文件夹右键git bash here 然后输入一下命令 npm install hexo-cli -g npm install hexo-deployer-git --save – hexo初始化hexo init – 本地查看初始化hexo效果启动hexo hexo g hexo s 执行以下命令，执行完即可登录 http://localhost:4000/ 查看效果 – 将博客部署到 Github上– 创建GitHub仓库到目前为止，我们的本地博客就成功搭建了，但是现在我们只能通过本地连接查看博客，我们要做的是让其他人也能够访问我们的博客，这就需要我们将博客部署到Github 上 一、注册 Github 账户：点击此处访问 Github 官网，点击 Sign Up 注册账户 二、创建项目代码库：点击 New repository 开始创建，步骤及注意事项见图： – 配置SSH密匙使用命令创建密匙 ssh-keygen -t rsa -C &quot;your email@example.com&quot; 一路回车,然后到 C:\\用户\\当前用户\\.ssh 找到 id_rsa.pub 文件复制其中内容 在 GitHub 账户中添加你的公钥 进入Settings: 点击 SSH and GPG Keys: New SSH Key 然后把复制好的密匙输入就可以了 测试是否成功代码 ssh -T git@github.com 如果提示你如果提示你 Hi SHUAIME! You&#39;ve successfully authenticated, but GitHub does not provide shell access. 此时证明配置成功 – 将本地更新到GitHub上选择刚才新建的项目 ,选择Clone or download 然后一键复制 接着打开你创建的Hexo文件夹 (如: D:\\Desktop\\blog ) 打开该文件夹下的config.yml 按Ctrl+F 查找deploy 关键字 按照下图修改 最后在Hexo 文件夹下 执行以下命令 hexo g -d 访问博客 博客地址：https://你的用户名.github.io，比如我的是：https://SHUAIME.github.io 【未完待续…..】","categories":[{"name":"Hexo","slug":"Hexo","permalink":"https://www.shuaime.top/categories/Hexo/"},{"name":"BLOG","slug":"BLOG","permalink":"https://www.shuaime.top/categories/BLOG/"},{"name":"GitHub","slug":"GitHub","permalink":"https://www.shuaime.top/categories/GitHub/"}],"tags":[{"name":"hexo","slug":"hexo","permalink":"https://www.shuaime.top/tags/hexo/"},{"name":"blog","slug":"blog","permalink":"https://www.shuaime.top/tags/blog/"},{"name":"GitHub","slug":"GitHub","permalink":"https://www.shuaime.top/tags/GitHub/"},{"name":"Node","slug":"Node","permalink":"https://www.shuaime.top/tags/Node/"}],"keywords":[{"name":"Hexo","slug":"Hexo","permalink":"https://www.shuaime.top/categories/Hexo/"},{"name":"BLOG","slug":"BLOG","permalink":"https://www.shuaime.top/categories/BLOG/"},{"name":"GitHub","slug":"GitHub","permalink":"https://www.shuaime.top/categories/GitHub/"}]},{"title":"Java学习篇之IO流","slug":"IO","date":"2019-10-12T06:47:09.000Z","updated":"2020-03-30T13:05:06.953Z","comments":true,"path":"posts/ac21c0cc/","link":"","permalink":"https://www.shuaime.top/posts/ac21c0cc/","excerpt":"写作时间：2019-10-12实现目标：总结Java IO流知识点涉及知识：Java IO流","text":"写作时间：2019-10-12实现目标：总结Java IO流知识点涉及知识：Java IO流 【思维导图】 【IO流分类】根据处理数据类型的不同分为字节流 和 字符流 根据数据流向不同分为输出流 和 输入流 字节流和字符流的区别 字符流底层是字节流 字符流需要考虑编码问题 字节流不需要 字符流只能操作文本文件 字节流可以操作所有文件 字节流是直接操作文件的 字符流是通过缓存操作文件 输入流和输出流 输入流只能进行读操作，输出流只能进行写操作，程序中需要根据待传输数据的不同特性而使用不同的流。 【字节输入流 InputStream】InputStream 是所有的输入字节流的父类，它是一个抽象类。 ByteArrayInputStream、StringBufferInputStream、FileInputStream 是三种基本的介质流，它们分别从Byte 数组、StringBuffer、和本地文件中读取数据。 PipedInputStream 是从与其它线程共用的管道中读取数据，与Piped 相关的知识后续单独介绍。 ObjectInputStream 和所有FilterInputStream 的子类都是装饰流（装饰器模式的主角） 【字节输出流 InputStream】OutputStream 是所有的输出字节流的父类，它是一个抽象类。 ByteArrayOutputStream、FileOutputStream 是两种基本的介质流，它们分别向Byte 数组、和本地文件中写入数据。 PipedOutputStream 是向与其它线程共用的管道中写入数据。 ObjectOutputStream 和所有FilterOutputStream 的子类都是装饰流。 总的来说 输入流：InputStream或者Reader：从文件中读到程序中； 输出流：OutputStream或者Writer：从程序中输出到文件中； 【字节流操作文件】FileInputStream读取文件内容package com.io; import java.io.FileInputStream; import java.io.IOException; public static void main(String[] args){ try( FileInputStream in = new FileInputStream(&quot;D:\\\\1.txt&quot;); ){ byte[] bs = new byte[1024]; int len = 0; while((len = bis.read(bs)) != -1){ System.out.println(new String(bs,0,len)); } }catch(IOException e){ e.printStackTrace(); } } FileOutputStream 实现复制文件package com.io; import java.io.FileInputStream; import java.io.FileOutPutStream; import java.io.IOException; public static void main(String[] args){ try( FileInputStream in = new FileInputStream(&quot;D:\\\\1.txt&quot;); FileOutPutStream out = new FileOutputStream(&quot;D:\\\\2.txt&quot;); ){ byte[] bs = new byte[1024]; int len = 0; while((len = in.read(bs))!=-1){ out.write(bs,0,len); } }catch(IOException e){ e.printStackTrace(); } } 注: 在jdk7后，提供了一种新的方式：try-with-resources方式来管理资源，在try中声明资源，当程序执行完后，会自动将声明的资源关闭掉 【字符流实现复制文件】package com.io; import java.io.BufferedInputStream; import java.io.BufferedOutputStream; import java.io.IOException; public static void main(String[] args){ try( BufferedInputStream bis = new BufferedInputStream(&quot;D:\\\\1.txt&quot;); BufferedOutputStream bos = new BufferedOutputStream(&quot;D:\\\\2.txt&quot;); ){ byte[] bs = new byte[1024]; int len = 0; while((len = bis.read(bs))!=-1){ bos.write(bs,0,len); } }catch(IOException e){ e.printStackTrace(); } } 【对象的序列化】目的：将一个具体的对象进行持久化，写入到硬盘上。注意：静态数据不能被序列化，因为静态数据不在堆内存中，是存储在静态方法区中。 如何将非静态的数据不进行序列化？用transient 关键字修饰此变量即可。 Serializable：用于启动对象的序列化功能，可以强制让指定类具备序列化功能，该接口中没有成员，这是一个标记接口。这个标记接口用于给序列化类提供UID。这个uid是依据类中的成员的数字签名进行运行获取的。如果不需要自动获取一个uid，可以在类中，手动指定一个名称为serialVersionUID id号。依据编译器的不同，或者对信息的高度敏感性。最好每一个序列化的类都进行手动显示的UID的指定。 实体类 package com.yan.entity; import java.io.Serializable; public class Student implements Serializable{//实现Serializable接口 /** * */ private static final long serialVersionUID = 8691134767391266961L; private String name; private Integer age; public Student() { super(); } public Student(String name, Integer age) { super(); this.name = name; this.age = age; } public String getName() { return name; } public void setName(String name) { this.name = name; } public Integer getAge() { return age; } public void setAge(Integer age) { this.age = age; } @Override public String toString() { return &quot;Student [name=&quot; + name + &quot;, age=&quot; + age + &quot;]&quot;; } } 测试类 package com.yan.demo; import java.io.FileInputStream; import java.io.FileOutputStream; import java.io.ObjectInputStream; import java.io.ObjectOutputStream; import org.junit.Test; import com.yan.entity.Student; public class ObjectDemo { @Test public void fun1() { try ( //序列化 ObjectOutputStream oos = new ObjectOutputStream(new FileOutputStream(&quot;D:\\\\Desktop\\\\1.txt&quot;)); ){ Student s = new Student(&quot;张三&quot;,12); oos.writeObject(s); } catch (Exception e) { e.printStackTrace(); } } @Test public void fun2() { try ( //反序列化 ObjectInputStream ois = new ObjectInputStream(new FileInputStream(&quot;D:\\\\Desktop\\\\1.txt&quot;)); ){ Student s = (Student) ois.readObject(); System.out.println(s); } catch (Exception e) { e.printStackTrace(); } } } 【未完待续…..】","categories":[{"name":"Java","slug":"Java","permalink":"https://www.shuaime.top/categories/Java/"}],"tags":[{"name":"Java","slug":"Java","permalink":"https://www.shuaime.top/tags/Java/"},{"name":"IO流","slug":"IO流","permalink":"https://www.shuaime.top/tags/IO流/"}],"keywords":[{"name":"Java","slug":"Java","permalink":"https://www.shuaime.top/categories/Java/"}]},{"title":"Java学习篇之多线程","slug":"thread","date":"2019-10-11T06:46:52.000Z","updated":"2020-03-30T13:09:51.850Z","comments":true,"path":"posts/4ad2c499/","link":"","permalink":"https://www.shuaime.top/posts/4ad2c499/","excerpt":"写作时间：2019-10-11 实现目标：总结Java线程概念，线程并发情况与解决方案涉及知识：Java多线程","text":"写作时间：2019-10-11 实现目标：总结Java线程概念，线程并发情况与解决方案涉及知识：Java多线程 【思维导图】 【线程的创建】线程是操作系统能够进行运算调度的最小单位。它被包含在进程之中，是进程中的实际运作单位 线程创建基本方式为: 继承Thread类 实现Runnable接口 通过 Callable 和 Future 创建线程 //继承Thead类 package com.thread; public class ThreadTest extends Thread{ int i = 0; //重写run方法，run方法的方法体就是现场执行体 public void run(){ for(;i&lt;100;i++){ System.out.println(Thread.currentThread().getName()+&quot; &quot;+i); } } public static void main(String[] args){ for(int i = 0;i&lt; 100;i++){ System.out.println(Thread.currentThread().getName()+&quot; : &quot;+i); if(i==20){ new FirstThreadTest().start(); new FirstThreadTest().start(); } } } } //`实现Runnable接口` package com.thread; public class RunnableTest implements Runnable{ public void run(){ for(;i&lt;100;i++){ System.out.println(Thread.currentThread().getName()+&quot; &quot;+i); } } public static void main(String[] args){ for(int i = 0;i&lt; 100;i++){ System.out.println(Thread.currentThread().getName()+&quot; : &quot;+i); if(i==20){ RunnableTest rtt = new RunnableTest(); new Thread(rtt,&quot;新线程1&quot;).start(); new Thread(rtt,&quot;新线程2&quot;).start(); } } } } //通过 Callable 和 Future 创建线程 package com.thread; public class CallableThreadTest implements Callable&lt;Integer&gt; { public static void main(String[] args) { CallableThreadTest ctt = new CallableThreadTest(); FutureTask&lt;Integer&gt; ft = new FutureTask&lt;&gt;(ctt); for(int i = 0;i &lt; 100;i++) { System.out.println(Thread.currentThread().getName()+&quot; 的循环变量i的值&quot;+i); if(i==20) { new Thread(ft,&quot;有返回值的线程&quot;).start(); } } try { System.out.println(&quot;子线程的返回值：&quot;+ft.get()); } catch (InterruptedException e){ e.printStackTrace(); } catch (ExecutionException e) { e.printStackTrace(); } } public Integer call() throws Exception { int i = 0; for(;i&lt;100;i++) { System.out.println(Thread.currentThread().getName()+&quot; &quot;+i); } return i; } } 【线程的状态】线程的状态分析: 新建状态（New）：新创建了一个线程对象。 就绪状态（Runnable）：线程对象创建后，其他线程调用了该对象的start()方法。该状态的线程位于可运行线程池中，变得可运行，等待获取CPU的使用权。 运行状态（Running）：就绪状态的线程获取了CPU，执行程序代码。 阻塞状态（Blocked）：阻塞状态是线程因为某种原因放弃CPU使用权，暂时停止运行。直到线程进入就绪状态，才有机会转到运行状态。阻塞的情况分三种： 等待阻塞：运行的线程执行wait()方法，JVM会把该线程放入等待池中。(wait会释放持有的锁) 同步阻塞：运行的线程在获取对象的同步锁时，若该同步锁被别的线程占用，则JVM会把该线程放入锁池中。 其他阻塞：运行的线程执行sleep()或join()方法，或者发出了I/O请求时，JVM会把该线程置为阻塞状态。当sleep()状态超时、join()等待线程终止或者超时、或者I/O处理完毕时，线程重新转入就绪状态。（注意,sleep是不会释放持有的锁） 死亡状态（Dead）：线程执行完了或者因异常退出了run()方法，该线程结束生命周期。 【线程的常用方法】 currentThread() 返回当前正在执行的线程对象的引用 getName() 返回此线程的名称 getPriority() 返回此线程的优先级 setName(String name) 改变该线程的名称等于参数 name setPriority(int newPriority) 更改此线程的优先级 sleep(long millis) 当前正在执行的线程休眠 interrupt() 中断这个线程(sleep,join,wait) join() 等待该线程死亡 setDaemon(boolean on) 标志着该线程是 daemon线程或用户线程 GC对应的线程是守护线程 yield() 线程礼让 暂停当前正在执行的线程对象，并执行其他线程 【线程不安全问题】首先我们要了解线程不安全问题是如何产生的 多线程的环境下 多个线程使用共同的资源 同时修改这个共同的资源产生了线程不安全问题 要解决线程不安全问题 有这几个解决方式: 同步方法，把 synchronized 作用在方法上 同步代码， synchronized 作用在公共变量上111 特殊域变量，使用 volatile 关键字修饰的变量，保证一个最新值 重入锁，在 JDK 中提供了一把锁的机制， java.util.concurrent.ReentrantLock 类,lock()加锁,unlock()解锁 线程变量（局部变量），把全局属性交个 ThreadLocal 管理，可以把全局变量转换成局部变量处理，使用 set 赋值、 get 取值单例对象多例属性 阻塞队列，队列一定能保证先进先出 原子变量实现线程同步 【线程死锁】Java 多线程中的死锁 死锁是指两个或两个以上的进程在执行过程中，因争夺资源而造成的一种互相等待的现象，若无外力作用，它们都将无法推进下去。这是一个严重的问题，因为死锁会让你的程序挂起无法完成任务 代码如下 public class LockTest { public static String obj1 = &quot;obj1&quot;; public static String obj2 = &quot;obj2&quot;; public static void main(String[] args) { LockA la = new LockA(); new Thread(la).start(); LockB lb = new LockB(); new Thread(lb).start(); } } class LockA implements Runnable{ public void run() { try { System.out.println(new Date().toString() + &quot; LockA 开始执行&quot;); while(true){ synchronized (LockTest.obj1) { System.out.println(new Date().toString() + &quot; LockA 锁住 obj1&quot;); Thread.sleep(3000); // 此处等待是给B能锁住机会 synchronized (LockTest.obj2) { System.out.println(new Date().toString() + &quot; LockA 锁住 obj2&quot;); Thread.sleep(60 * 1000); // 为测试，占用了就不放 } } } } catch (Exception e) { e.printStackTrace(); } } } class LockB implements Runnable{ public void run() { try { System.out.println(new Date().toString() + &quot; LockB 开始执行&quot;); while(true){ synchronized (LockTest.obj2) { System.out.println(new Date().toString() + &quot; LockB 锁住 obj2&quot;); Thread.sleep(3000); // 此处等待是给A能锁住机会 synchronized (LockTest.obj1) { System.out.println(new Date().toString() + &quot; LockB 锁住 obj1&quot;); Thread.sleep(60 * 1000); // 为测试，占用了就不放 } } } } catch (Exception e) { e.printStackTrace(); } } } 解决方式为: 等待(wait)唤醒(notify)机制 【未完待续……】","categories":[{"name":"Java","slug":"Java","permalink":"https://www.shuaime.top/categories/Java/"}],"tags":[{"name":"Java","slug":"Java","permalink":"https://www.shuaime.top/tags/Java/"},{"name":"多线程","slug":"多线程","permalink":"https://www.shuaime.top/tags/多线程/"}],"keywords":[{"name":"Java","slug":"Java","permalink":"https://www.shuaime.top/categories/Java/"}]},{"title":"Java学习篇之集合篇","slug":"list","date":"2019-10-10T06:40:07.000Z","updated":"2020-03-30T13:08:03.341Z","comments":true,"path":"posts/e937c3c0/","link":"","permalink":"https://www.shuaime.top/posts/e937c3c0/","excerpt":"写作时间：2019-10-10实现目标：总结Java集合概念，攻克集合难点涉及知识：Java集合","text":"写作时间：2019-10-10实现目标：总结Java集合概念，攻克集合难点涉及知识：Java集合 【思维导图】 【Java集合划分】【Java集合简介】Java集合是java提供的一个工具包，全部继承自`java.util.*`。主要包括两大接口`Collection`接口和`Map`接口以及相关的工具类（`Iterator`迭代器接口、`Enumeration`枚举类、`Arrays`和`Colletions`） Collection是一个接口，包含List列表和Set集合。其中List是有序的队列，元素值可以重复，索引从0开始，实现类有LinkedList，ArrayList，Vector；而Set是一个不允许有重复元素的集合，Set的实现类有HashSet和TreeSet。HashSet依赖于HashMap，它实际上是通过HashMap实现的；TreeSet依赖于TreeMap，它实际上是通过TreeMap实现的。 Map是一个映射接口，通过key-value键值对实现。实现类有HashMap，TreeMap，WeakHashMap，Hashtable。 Iterator是遍历集合的工具，Enumeration也是遍历集合，但它的的功能要比Iterator少，只能在Hashtable, Vector, Stack中使用。 Arrays和`Collections是操作数组、集合的两个工具类。 【Collection接口】【List集合】List继承了Collection，是有序的列表。 实现类有ArrayList、LinkedList、Vector、Stack等 ArrayList是基于数组实现的，是一个数组队列。可以动态的增加容量！ LinkedList是基于链表实现的，是一个双向循环列表。可以被当做堆栈使用！ Vector是基于数组实现的，是一个矢量队列，是线程安全的！ Stack是基于数组实现的，是栈，它继承与Vector，特性是FILO（先进后出）！ 【List特点】有序可重复 存储不同类型的元素 长度可变 【ArrayList（动态数组） 特点】有序可以重复 类型可以不相同（建议相同，使用泛型） 长度可变 内存地址是连续的 查找效率很高 增删效率较低 【LinkedList（链表）】 有序可以重复 类型可以不相同（建议相同，使用泛型） 长度可变 内存地址不是连续的 修改元素效率高（添加、修改、删除） 【ArrayList与LinkedList区别】ArrayList底层是数组，LinkedList底层是链表 ArrayList元素存储地址是连续的，遍历比较快，0操作元素比较慢LinkedList元素存储地址是相互指向的，遍历比较慢，操作元素比较快 【List遍历方式】//下标遍历 for(int i = 0;i&lt;list.size();i++){ System.out.println(list.get(i)); } //forEach遍历 for(String value:list){ System.out.println(value); } //迭代器遍历 Iterator it1 = list.iterator(); while(it1.hasNext()){ System.out.println(it1.next()); } 【Set集合】Set的两个实现类，HashSet和TreeSet HashSet实现本质其实就是HashMap，HashSet里面的元素是无序的。 TreeSet实现本质其实就是TreeSet,TreeSet里面的元素是有序的。 【HashSet特点】 元素是无序 元素不可以重复 没有下标 ​ 【TreeSet特点】元素是有序，按自然元素排序 元素不可以重复 没有下标 【LinkedHashSet】元素是有序，按插入顺序迭代 元素不可以重复 没有下标 【Set集合去重原理】Set集合只针对引用类型进行去重，引用类型必须重写hashCode与equals两个方法，不然不能去重 遍历与List相似 【Map集合】在Java中java.util.Map表示一个Map，Map是以键值对的方式存储数据， 一个key对应一个value，key是唯一的不可以重复，value可以重复，也是数据结构的一种 【HashMap的简介】HashMap是基于哈希表的Map实现的的，一个Key对应一个Value，允许使用null键和null值,不保证映射的顺序，特别是它不保证该顺序恒久不变！也不是同步的 【HashMap的特点】HashMap是通过哈希表来存储一个key-value的键值对，每个key对应一个value，允许key和value为null！ hash HashMap 的实例有两个参数影响其性能：初始容量 和加载因子。容量是哈希表中桶的数量，初始容量只是哈希表在创建时的容量。HashMap的容量不足的时候，可以自动扩容resize(),但是最大容量为MAXIMUM_CAPACITY==2^30！ put和get都是分为null和非null进行判断！ resize非常耗时的操作，因此，我们在用HashMap的时，最好能提前预估下HashMap中元素的个数，这样有助于提高HashMap的性能。 求hash值和索引值的方法，这两个方法便是HashMap设计的最为核心的部分，二者结合能保证哈希表中的元素尽可能均匀地散列。 【Map的遍历方式】//使用keySet()方法遍历 for (String key : map.keySet()) { System.out.println(key + &quot; : &quot; + map.get(key)); } //使用map的entrySet()方法遍历 for (Entry&lt;String, String&gt; entry : map.entrySet()) { System.out.println(entry.getKey() + &quot; : &quot; + entry.getValue()); } //iterator迭代器遍历keySet Iterator&lt;String&gt; it = map.keySet().iterator(); while(it1.hasNext()) { String key = it1.next(); System.out.println(key + &quot; : &quot; + map.get(key)); } //iterator迭代器遍历entrySet Iterator&lt;Entry&lt;String, String&gt;&gt; it = map.entrySet().iterator(); while(it3.hasNext()) { Entry&lt;String, String&gt; entry = it3.next(); System.out.println(entry.getKey() + &quot; : &quot; + entry.getValue()); } 【未完待续……】","categories":[{"name":"Java","slug":"Java","permalink":"https://www.shuaime.top/categories/Java/"}],"tags":[{"name":"Java","slug":"Java","permalink":"https://www.shuaime.top/tags/Java/"},{"name":"集合","slug":"集合","permalink":"https://www.shuaime.top/tags/集合/"}],"keywords":[{"name":"Java","slug":"Java","permalink":"https://www.shuaime.top/categories/Java/"}]},{"title":"Hello World","slug":"hello-world","date":"2019-10-01T04:40:07.000Z","updated":"2020-03-30T13:28:48.257Z","comments":true,"path":"posts/4a17b156/","link":"","permalink":"https://www.shuaime.top/posts/4a17b156/","excerpt":"如果你能做梦，你就能实现它。——吉格·金克拉","text":"如果你能做梦，你就能实现它。——吉格·金克拉 真正的人生，只有在经过艰难卓绝的斗争之后才能实现。——塞涅卡","categories":[{"name":"BLOG","slug":"BLOG","permalink":"https://www.shuaime.top/categories/BLOG/"}],"tags":[],"keywords":[{"name":"BLOG","slug":"BLOG","permalink":"https://www.shuaime.top/categories/BLOG/"}]},{"title":"Hexo-Theme-Sakura","slug":"Hexo-Theme-Sakura","date":"2018-12-12T14:16:01.000Z","updated":"2020-03-31T10:06:53.855Z","comments":true,"path":"posts/186f70d4/","link":"","permalink":"https://www.shuaime.top/posts/186f70d4/","excerpt":"","text":"hexo-theme-sakura主题 English document 基于WordPress主题Sakura修改成Hexo的主题。 demo预览 正在开发中…… 交流群若你是使用者，加群QQ: 801511924 若你是创作者，加群QQ: 194472590 主题特性 首页大屏视频 首页随机封面 图片懒加载 valine评论 fancy-box相册 pjax支持，音乐不间断 aplayer音乐播放器 多级导航菜单（按现在大部分hexo主题来说，这也算是个特性了） 赞赏作者如果喜欢hexo-theme-sakura主题，可以考虑资助一下哦~非常感激！ paypal | Alipay 支付宝 | WeChat Pay 微信支付 未完善的使用教程那啥？老实说我目前也不是很有条理233333333~ 1、主题下载安装hexo-theme-sakura建议下载压缩包格式，因为除了主题内容还有些source的配置对新手来说比较太麻烦，直接下载解压就省去这些麻烦咯。 下载好后解压到博客根目录（不是主题目录哦，重复的选择替换）。接着在命令行（cmd、bash）运行npm i安装依赖。 2、主题配置博客根目录下的_config配置站点 # Site title: 你的站点名 subtitle: description: 站点简介 keywords: author: 作者名 language: zh-cn timezone: 部署 deploy: type: git repo: github: 你的github仓库地址 # coding: 你的coding仓库地址 branch: master 备份 （使用hexo b发布备份到远程仓库） backup: type: git message: backup my blog of https://honjun.github.io/ repository: # 你的github仓库地址,备份分支名 （建议新建backup分支） github: https://github.com/honjun/honjun.github.io.git,backup # coding: https://git.coding.net/hojun/hojun.git,backup 主题目录下的_config配置其中标明【改】的是需要修改部门，标明【选】是可改可不改，标明【非】是不用改的部分 # site name # 站点名 【改】 prefixName: さくら荘その siteName: hojun # favicon and site master avatar # 站点的favicon和头像 输入图片路径（下面的配置是都是cdn的相对路径，没有cdn请填写完整路径，建议使用jsdeliver搭建一个cdn啦，先去下载我的cdn替换下图片就行了，简单方便~）【改】 favicon: /images/favicon.ico avatar: /img/custom/avatar.jpg # 站点url 【改】 url: https://sakura.hojun.cn # 站点介绍（或者说是个人签名）【改】 description: Live your life with passion! With some drive! # 站点cdn，没有就为空 【改】 若是cdn为空，一些图片地址就要填完整地址了，比如之前avatar就要填https://cdn.jsdelivr.net/gh/honjun/cdn@1.6/img/custom/avatar.jpg cdn: https://cdn.jsdelivr.net/gh/honjun/cdn@1.6 # 开启pjax 【选】 pjax: 1 # 站点首页的公告信息 【改】 notice: hexo-Sakura主题已经开源，目前正在开发中... # 懒加载的加载中图片 【选】 lazyloadImg: https://cdn.jsdelivr.net/gh/honjun/cdn@1.6/img/loader/orange.progress-bar-stripe-loader.svg # 站点菜单配置 【选】 menus: 首页: { path: /, fa: fa-fort-awesome faa-shake } 归档: { path: /archives, fa: fa-archive faa-shake, submenus: { 技术: {path: /categories/技术/, fa: fa-code }, 生活: {path: /categories/生活/, fa: fa-file-text-o }, 资源: {path: /categories/资源/, fa: fa-cloud-download }, 随想: {path: /categories/随想/, fa: fa-commenting-o }, 转载: {path: /categories/转载/, fa: fa-book } } } 清单: { path: javascript:;, fa: fa-list-ul faa-vertical, submenus: { 书单: {path: /tags/悦读/, fa: fa-th-list faa-bounce }, 番组: {path: /bangumi/, fa: fa-film faa-vertical }, 歌单: {path: /music/, fa: fa-headphones }, 图集: {path: /tags/图集/, fa: fa-photo } } } 留言板: { path: /comment/, fa: fa-pencil-square-o faa-tada } 友人帐: { path: /links/, fa: fa-link faa-shake } 赞赏: { path: /donate/, fa: fa-heart faa-pulse } 关于: { path: /, fa: fa-leaf faa-wrench , submenus: { 我？: {path: /about/, fa: fa-meetup}, 主题: {path: /theme-sakura/, fa: iconfont icon-sakura }, Lab: {path: /lab/, fa: fa-cogs }, } } 客户端: { path: /client/, fa: fa-android faa-vertical } RSS: { path: /atom.xml, fa: fa-rss faa-pulse } # Home page sort type: -1: newer first，1: older first. 【非】 homePageSortType: -1 # Home page article shown number) 【非】 homeArticleShown: 10 # 背景图片 【选】 bgn: 8 # startdash面板 url, title, desc img 【改】 startdash: - {url: /theme-sakura/, title: Sakura, desc: 本站 hexo 主题, img: /img/startdash/sakura.md.png} - {url: http://space.bilibili.com/271849279, title: Bilibili, desc: 博主的b站视频, img: /img/startdash/bilibili.jpg} - {url: /, title: hojun的万事屋, desc: 技术服务, img: /img/startdash/wangshiwu.jpg} # your site build time or founded date # 你的站点建立日期 【改】 siteBuildingTime: 07/17/2018 # 社交按钮(social) url, img PC端配置 【改】 social: github: {url: http://github.com/honjun, img: /img/social/github.png} sina: {url: http://weibo.com/mashirozx?is_all=1, img: /img/social/sina.png} wangyiyun: {url: http://weibo.com/mashirozx?is_all=1, img: /img/social/wangyiyun.png} zhihu: {url: http://weibo.com/mashirozx?is_all=1, img: /img/social/zhihu.png} email: {url: http://weibo.com/mashirozx?is_all=1, img: /img/social/email.svg} wechat: {url: /#, qrcode: /img/custom/wechat.jpg, img: /img/social/wechat.png} # 社交按钮(msocial) url, img 移动端配置 【改】 msocial: github: {url: http://github.com/honjun, fa: fa-github, color: 333} weibo: {url: http://weibo.com/mashirozx?is_all=1, fa: fa-weibo, color: dd4b39} qq: {url: https://wpa.qq.com/msgrd?v=3&amp;uin=954655431&amp;site=qq&amp;menu=yes, fa: fa-qq, color: 25c6fe} # 赞赏二维码（其中wechatSQ是赞赏单页面的赞赏码图片）【改】 donate: alipay: /img/custom/donate/AliPayQR.jpg wechat: /img/custom/donate/WeChanQR.jpg wechatSQ: /img/custom/donate/WeChanSQ.jpg # 首页视频地址为https://cdn.jsdelivr.net/gh/honjun/hojun@1.2/Unbroken.mp4，配置如下 【改】 movies: url: https://cdn.jsdelivr.net/gh/honjun/hojun@1.2 # 多个视频用逗号隔开，随机获取。支持的格式目前已知MP4,Flv。其他的可以试下，不保证有用 name: Unbroken.mp4 # 左下角aplayer播放器配置 主要改id和server这两项，修改详见[aplayer文档] 【改】 aplayer: id: 2660651585 server: netease type: playlist fixed: true mini: false autoplay: false loop: all order: random preload: auto volume: 0.7 mutex: true # Valine评论配置【改】 valine: true v_appId: GyC3NzMvd0hT9Yyd2hYIC0MN-gzGzoHsz v_appKey: mgOpfzbkHYqU92CV4IDlAUHQ 分类页和标签页配置分类页 标签页 配置项在\\themes\\Sakura\\languages\\zh-cn.yml里。新增一个分类或标签最好加下哦，当然嫌麻烦可以直接使用一张默认图片（可以改主题或者直接把404图片替换下，征求下意见要不要给这个在配置文件中加个开关，可以issue或群里提出来），现在是没设置的话会使用那种倒立小狗404哦。 #category # 按分类名创建 技术: #中文标题 zh: 野生技术协会 # 英文标题 en: Geek – Only for Love # 封面图片 img: https://cdn.jsdelivr.net/gh/honjun/cdn@1.6/img/banner/coding.jpg 生活: zh: 生活 en: live img: https://cdn.jsdelivr.net/gh/honjun/cdn@1.6/img/banner/writing.jpg #tag # 标签名即是标题 悦读: # 封面图片 img: https://cdn.jsdelivr.net/gh/honjun/cdn@1.6/img/banner/reading.jpg 单页面封面配置如留言板页面页面，位于source下的comment下，打开index.md如下： --- title: comment date: 2018-12-20 23:13:48 keywords: 留言板 description: comments: true # 在这里配置单页面头部图片，自定义替换哦~ photos: https://cdn.jsdelivr.net/gh/honjun/cdn@1.4/img/banner/comment.jpg --- 单页面配置番组计划页 （请直接在下载后的文件中改，下面的添加了注释可能会有些影响） --- layout: bangumi title: bangumi comments: false date: 2019-02-10 21:32:48 keywords: description: bangumis: # 番组图片 - img: https://lain.bgm.tv/pic/cover/l/0e/1e/218971_2y351.jpg # 番组名 title: 朝花夕誓——于离别之朝束起约定之花 # 追番状态 （追番ing/已追完） status: 已追完 # 追番进度 progress: 100 # 番剧日文名称 jp: さよならの朝に約束の花をかざろう # 放送时间 time: 放送时间: 2018-02-24 SUN. # 番剧介绍 desc: 住在远离尘嚣的土地，一边将每天的事情编织成名为希比欧的布，一边静静生活的伊欧夫人民。在15岁左右外表就停止成长，拥有数百年寿命的他们，被称为“离别的一族”，并被视为活着的传说。没有双亲的伊欧夫少女玛奇亚，过着被伙伴包围的平稳日子，却总感觉“孤身一人”。他们的这种日常，一瞬间就崩溃消失。追求伊欧夫的长寿之血，梅萨蒂军乘坐着名为雷纳特的古代兽发动了进攻。在绝望与混乱之中，伊欧夫的第一美女蕾莉亚被梅萨蒂带走，而玛奇亚暗恋的少年克里姆也失踪了。玛奇亚虽然总算逃脱了，却失去了伙伴和归去之地……。 - img: https://lain.bgm.tv/pic/cover/l/0e/1e/218971_2y351.jpg title: 朝花夕誓——于离别之朝束起约定之花 status: 已追完 progress: 50 jp: さよならの朝に約束の花をかざろう time: 放送时间: 2018-02-24 SUN. desc: 住在远离尘嚣的土地，一边将每天的事情编织成名为希比欧的布，一边静静生活的伊欧夫人民。在15岁左右外表就停止成长，拥有数百年寿命的他们，被称为“离别的一族”，并被视为活着的传说。没有双亲的伊欧夫少女玛奇亚，过着被伙伴包围的平稳日子，却总感觉“孤身一人”。他们的这种日常，一瞬间就崩溃消失。追求伊欧夫的长寿之血，梅萨蒂军乘坐着名为雷纳特的古代兽发动了进攻。在绝望与混乱之中，伊欧夫的第一美女蕾莉亚被梅萨蒂带走，而玛奇亚暗恋的少年克里姆也失踪了。玛奇亚虽然总算逃脱了，却失去了伙伴和归去之地……。 --- 友链页 （请直接在下载后的文件中改，下面的添加了注释可能会有些影响） --- layout: links title: links # 创建日期，可以改下 date: 2018-12-19 23:11:06 # 图片上的标题，自定义修改 keywords: 友人帐 description: # true/false 开启/关闭评论 comments: true # 页面头部图片，自定义修改 photos: https://cdn.jsdelivr.net/gh/honjun/cdn@1.4/img/banner/links.jpg # 友链配置 links: # 类型分组 - group: 个人项目 # 类型简介 desc: 充分说明这家伙是条咸鱼 &lt; (￣︶￣)&gt; items: # 友链链接 - url: https://shino.cc/fgvf # 友链头像 img: https://cloud.moezx.cc/Picture/svg/landscape/fields.svg # 友链站点名 name: Google # 友链介绍 下面雷同 desc: Google 镜像 - url: https://shino.cc/fgvf img: https://cloud.moezx.cc/Picture/svg/landscape/fields.svg name: Google desc: Google 镜像 # 类型分组... - group: 小伙伴们 desc: 欢迎交换友链 ꉂ(ˊᗜˋ) items: - url: https://shino.cc/fgvf img: https://cloud.moezx.cc/Picture/svg/landscape/fields.svg name: Google desc: Google 镜像 - url: https://shino.cc/fgvf img: https://cloud.moezx.cc/Picture/svg/landscape/fields.svg name: Google desc: Google 镜像 --- 写文章配置主题集成了个人插件hexo-tag-bili和hexo-tag-fancybox_img。其中hexo-tag-bili用来在文章或单页面中插入B站外链视频，使用语法如下： {% bili video_id [page] %} 详细使用教程详见hexo-tag-bili。 hexo-tag-fancybox_img用来在文章或单页面中图片，使用语法如下： {% fb_img src [caption] %} 详细使用教程详见hexo-tag-fancybox_img 还有啥，一时想不起来……To be continued…","categories":[{"name":"Hexo","slug":"Hexo","permalink":"https://www.shuaime.top/categories/Hexo/"}],"tags":[{"name":"web","slug":"web","permalink":"https://www.shuaime.top/tags/web/"},{"name":"悦读","slug":"悦读","permalink":"https://www.shuaime.top/tags/悦读/"}],"keywords":[{"name":"Hexo","slug":"Hexo","permalink":"https://www.shuaime.top/categories/Hexo/"}]}]}